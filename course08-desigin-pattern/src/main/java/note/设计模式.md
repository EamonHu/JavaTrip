# 设计模式



[toc]
## 六大设计原则
> 设计模式是一套理论，是软件界的先辈们总结出的一套可以反复使用的经验。它可以提高代码的可重用性，增强系统的可维护性，以及解决一系列的复杂问题。

在学习设计模式之前，先要明白六大设计原则，设计模式是在六大设计原则上的实践。

### 开闭原则

- 开闭原则定义：软件实体应该对扩展开放，对修改关闭。
- 开闭原则的好处：
  - 可以减少测试的工作量
  - 可以提高复用性
  - 可以提高可维护性
  - 面向对象开发的要求

### 单一职责原则

- 单一职责的定义是：应该有且仅有一个原因引起类的变更
- 单一职责的好处：
    - 类的复杂度降低，实现什么职责都有清晰明确的定义
    - 可读性提高
    - 可维护性提高
    - 变更引起风险降低
- 在写代码的时候，尽量做到单一职责。但职责的划分很难确认，要根据环境、项目、资源等而定，但还是尽量做到类的设计只有一个原因引起变化。

### 接口隔离原则

- 接口隔离原则的定义：
  - 客户端不应该依赖它不需要的接口
  - 类间的依赖关系应该建立在最小的接口上

> 总结一句话是：建立单一接口，不要建立臃肿庞大的接口。再通俗点就是：接口尽量细化，同时接口的方法尽量少。

```html
接口隔离原则和单一职责原则是相同的吗？

是不同的。单一职责注重的是职责，要求职责单一，属于业务逻辑上的划分。接口隔离原则要求接口的方法尽量少，当二者发生冲突时，首先满足单一职责原则。
```

- 接口隔离原则也就是要做到高内聚。
- 接口的设计粒度越小，系统越灵活，但是灵活的同时也带来了结构的复杂化，开发难度增加，可维护性降低。需要深入了解业务逻辑，根据经验和常识决定接口的粒度大小，太小增加开发工作量，太大灵活度降低。

### 迪米特法则

- 迪米特法则：一个对象应该对其他对象有最少的了解。
- 迪米特法则的核心观念就是类间的解耦，弱耦合，类的复用率才可以提供。如果一个方法放在本类中，既不增加类间关系，也不对本类产生负面影响，那就放置在本类中。

### 里氏替换原则

- 里式替换原则的定义：只要父类能出现的地方子类就可以出现，而且替代为子类也不会产生任何错误和异常，使用者可能根本不需要知道谁是父类谁是子类。但是，反过来就不行了，有子类出现的地方，父类未必能适应。
- 里式替换原则的目的就是增强程序的健壮性，版本升级时也可以保持非常好的兼容性。即使增加子类，原有的子类还可以继续运行。

### 依赖倒置原则
- 依赖倒置的表现：
    1. 模块间的依赖通过抽象发生，实现类之间不发生直接的依赖关系，其依赖关系是通过接口或抽象类产生的。
    2. 接口或抽象类不依赖于实现类。
    3. 实现类依赖接口或抽象类。

> 更加精简的定位是“面向接口编程”

- 采用依赖倒置原则可以减少类间的耦合性，提高系统的稳定性，降低并行开发引起的风险，提高代码的可读性和可维护性。
- 依赖倒置原则的本质就是通过抽象使各个类或模块的实现彼此独立，不互相影响，实现模块间的松耦合。核心就是“面向接口编程”
> 为什么叫“倒置”，首先说“正置”是什么意思，依赖正置就是类间的依赖是实实在在的实现类间的依赖，也就是面向实现编程，也是正常生活的思维，要开车就依赖车，要用电脑就依赖电脑，而编写程序需要对现实世界的事物进行抽象，抽象的结果就是有了抽象类和接口，然后我们根据系统设计的需要产生了抽象间的依赖，代替了人们传统思维中的事物间的依赖，“倒置”就是从这里产生的。

## 简单工厂模式

> 简单工厂模式是指由一个工厂对象决定创建出哪一种产品类的实例，属于创建者模式，但它不属于23种设计模式。

最直观的思维方式是需要什么，创建什么。例如我需要一门课程，那么就创建一门课程来：

```java
public class MathCourse {

    public void  create(){
        System.out.println("MathCourse创建数学课程");
    }
}

public class Test {
    public static void main(String[] args) {
        // 直接创建
        MathCourse mathCourse = new MathCourse();
        mathCourse.create();
    }
}

输出：
MathCourse创建数学课程
```

但是如果用户同时需要英语课、语文课、政治课...等，那么则需要创建多个课程。根据六大设计原则之一的依赖倒置原则：面向接口编程。可以新建一个学科接口类，实际学科去实现这个接口类：

```java
public interface Course {

    /**
     * 创建课程
     */
    void create();
}

public class MathCourseImpl implements Course {
    @Override
    public void create() {
        System.out.println("MathCourseImpl创建了数学课程");
    }
}

public class EnglishCourseImpl implements Course {
    @Override
    public void create() {
        System.out.println("EnglishCourseIml创建了英语课程");
    }
}

public class Test {
    public static void main(String[] args) {
       // 面向接口创建
        Course course = new MathCourseImpl();
        course.create();
        Course course1 = new EnglishCourseImpl();
        course1.create();
    }
}

输出：
MathCourseImpl创建了数学课程
EnglishCourseImpl创建了英语课程
```

面向接口编程提高了代码的可读性和可维护性，但是目前所有课程还是用户自己new出来的，如果创建过程比较麻烦，这样用户还需要了解每种课程(然而**用户并不关心课程如何创建的，只需要使用**)。这里可以提供一种工厂类，使用工厂类只要传入用户想要的东西，就可以返回结果，而不需要用户关注具体的创建过程，实现类之间的解耦。

```java
public class CourseFactory {
    /**
     * 通过if判断创建
     */
    public Course createByIf(String name) {
        if ("math".equals(name)) {
            return new MathCourseImpl();
        } else if ("english".equals(name)) {
            return new EnglishCourseImpl();
        } else {
            return null;
        }
    }
}

public class Test {
    public static void main(String[] args) {
        // 简单工厂创建
        // 通过if判断创建
        CourseFactory courseFactory = new CourseFactory();
        Course mathCourseIf = courseFactory.createByIf("math");
        System.out.println("=======if=========");
        mathCourseIf.create();
        System.out.println("=======if=========");
}

输出：
=======if=========
MathCourseImpl创建了数学课程
=======if=========
```

上面代码提供了工厂类，只需要传入相应的学科名就可以创建对应的课程类。如果课程很多，那么将会有很多的if、else判断，可以对工厂使用反射的方法进行优化。

```java
public class CourseFactory {
    /**
     * 通过反射创建
     */
    public Course createByReflect(String name) {
        try {
            if (!(null == name || "".equals(name))) {
                return (Course) Class.forName(name).newInstance();
            }
        } catch (Exception e) {
            e.printStackTrace();
            System.out.println("创建" + name + "实例失败！");
        }
        return null;
    }
}

public class Test {
    public static void main(String[] args) {
        // 通过反射创建
        System.out.println("=======reflect=========");
   courseFactory.createByReflect("cn.eamon.study.gp01_simple_factory.EnglishCourseImpl").create();
        System.out.println("=======reflect=========");
    }
}

输出：
=======reflect=========
EnglishCourse创建了英语课程
=======reflect=========
```

通过反射创建实例，能很好优化代码，但是在实际使用的时候对传参要求很高，需要输入类的全路径名称。再结合泛型可以继续优化代码：

```java
public class CourseFactory {
    /**
     * 通过反射+泛型指定创建类型课程
     */
    public Course createByReflectExtends(Class<? extends Course> clazz){
        try{
            if(null!=clazz){
                return clazz.newInstance();
            }
        }catch (Exception e){
            e.printStackTrace();
            System.out.println("创建" + clazz + "实例失败！");
        }
        return null;
    }
}

public class Test {
    public static void main(String[] args) {
        // 通过反射+泛型指定创建课程
        System.out.println("=======reflect+extends=========");
        courseFactory.createByReflectExtends(MathCourseImpl.class).create();
        System.out.println("=======reflect+extends=========");
    }
}

输出：
=======reflect+extends=========
MathCourseImpl创建了数学课程
=======reflect+extends=========
```

通过泛型传递，这样开发工具在你传参的时候，还能够智能化提醒，进一步增加使用的便捷性。



看看Calendar类是如何实例化的Calendar.getInstance()：

```java
public static Calendar getInstance()
    {
    	// 工厂创建Calendar实例
        return createCalendar(TimeZone.getDefault(), Locale.getDefault(Locale.Category.FORMAT));
    }

private static Calendar createCalendar(TimeZone zone,
                                           Locale aLocale)
    {
        CalendarProvider provider =
            // 工厂创建Calendar实例
            LocaleProviderAdapter.getAdapter(CalendarProvider.class, aLocale) 
                                 .getCalendarProvider();
        if (provider != null) {
            try {
                return provider.getInstance(zone, aLocale);
            } catch (IllegalArgumentException iae) {
                // fall back to the default instantiation
            }
        }
    ···
}

// 使用泛型指定入参类型
 public static LocaleProviderAdapter getAdapter(Class<? extends LocaleServiceProvider> var0, Locale var1) {...}
```



**简单工厂的优点**：只需要传入一个正确的参数，就可以获取你所需要的对象，无须知道其创建的细节。

**简单工厂的缺点**：工厂类的职责过重，增加新的场景时需要修改工厂类的判断逻辑，违背开闭原则；不易于扩展复杂的产品结构。

**适用场景**：工厂类负责创建的对象较少。

## 工厂方法模式

> 工厂方法模式是指定义一个创建对象的接口，但让实现这个接口的类来决定实例化哪个类，工厂方法让类的实例化推迟到子类中进行。

在简单工厂中提到**简单工厂的缺点是职责过重，既不符合单一原则也不符合开闭原则**，如何工厂方法模式在一定程度上可以解决简单工厂的缺点。

同样是面向课程接口实现具体的课程类：

```java
public interface ICourse {

    /**
     * 创建课程
     */
    void create();
}

public class EnglishCourseImpl implements ICourse {
    @Override
    public void create() {
        System.out.println("EnglishCourseImpl创建了英语课程");
    }
}

public class MathCourseImpl implements ICourse {
    @Override
    public void create() {
        System.out.println("MathCourseImpl创建了数学课程");
    }
}
```

与简单工厂的区别，进一步将工厂同课程面向接口编程：

```java
public interface ICourseFactory {
    /**
     * 创建课程工厂
     */
    ICourse create();
}

public class EnglishCourseFactory implements ICourseFactory {
    @Override
    public ICourse create() {
        return new EnglishCourseImpl();
    }
}

public class MathCourseFactory implements ICourseFactory {
    @Override
    public ICourse create() {
        return new MathCourseImpl();
    }
}
```

这样在用户使用的时候便可以实例化不同的工厂类，创建具体的课程：

```java
public class Test {
    public static void main(String[] args) {
        // 数学课程
        ICourseFactory factory = new MathCourseFactory();
        ICourse course = factory.create();
        course.create();
        // 英语课程
        factory = new EnglishCourseFactory();
        factory.create().create();
    }
}

输出：
MathCourseImpl创建了数学课程
EnglishCourseImpl创建了英语课程
```

![](.\pics\工模式类图.png)

相比较于简单工厂，它用户更好的扩展性；当出现新的应用场景时，只需要新增一个接口的实现类即可，不需要修改原来的代码。符合单一职责、接口隔离以及依赖倒置原则。



在slf4j中工厂方法模式的应用

![](.\pics\logger类图.png)



**工厂方法模式的优点**

- 有良好的封装性，代码结构清晰：创建产品对象，不需要知道创建过程，只要知道类名就可以，降低模块间的耦合。
- 工厂方法模式符合开闭原则，扩展性非常优秀：想要增加产品类，只要适当修改具体的工厂类或者扩展一个工厂类，就可以“拥抱变化”。

**工厂方法模式的缺点**

- 类的个数容易过多，增加了代码结构的复杂度
- 增加了系统的抽象性和理解难度

**适用场景**

- 创建对象需要大量重复的代码
- 客户端不依赖产品类如何被创建、实现等细节

## 抽象工厂模式

> 抽象工厂模式是指提供一个创建一系列相关或相互依赖对象的接口，无须指定他们具体的类。

在工厂方法模式提到其缺点是**类的个数过多，增加了代码结构的复杂度**，抽象工厂模式可以一定程度上解决工厂方法模式的缺点。抽象工厂模式根据业务属性将接口粗化，将相关的接口方法定义在同一个接口类中。



在学习课程的时候，是会做笔记和回答老师的提问。也就是说每个课程都会做笔记方法和回答问题的方法，在创建课程的时候一并实现做笔记方法和回答问题方法。先定义好相关的接口和类：

课程接口和实现类

```java
public interface ICourse {

    /**
     * 创建课程
     */
    void create();
}

public class EnglishCourseImpl implements ICourse {
    @Override
    public void create() {
        System.out.println("EnglishCourse创建了英语课程");
    }
}

public class MathCourseImpl implements ICourse {
    @Override
    public void create() {
        System.out.println("MathCourseImpl创建了数学课程");
    }
}

```

回答问题接口和实现类

```java
public interface IAnswer {
    /**
     * 回答问题
     */
    void speak();
}

public class EnglishAnswerImpl implements IAnswer {
    @Override
    public void speak() {
        System.out.println("回答英语问题");
    }
}

public class MathAnswerImpl implements IAnswer {
    @Override
    public void speak() {
        System.out.println("回答数学问题");
    }
}
```

笔记接口和实现类

```java
public interface INote {
    /**
     * 做笔记
     */
    void edit();
}

public class EnglishNoteImpl implements INote {
    @Override
    public void edit() {
        System.out.println("写英语笔记");
    }
}

public class MathNoteImpl implements INote {
    @Override
    public void edit() {
        System.out.println("写数学笔记");
    }
}
```

接着定义课程抽象工厂

```java
public abstract class CourseFactory {
    public void init(){
        System.out.println("初始化参数");
    }

    /**
     * 创建笔记
     */
    public abstract INote createNote();

    /**
     * 回答问题
     */
    public abstract IAnswer createAnswer();
}


public class EnglishCourseFactory extends CourseFactory {
    @Override
    public INote createNote() {
        return new EnglishNoteImpl();
    }

    @Override
    public IAnswer createAnswer() {
        return new EnglishAnswerImpl();
    }
}

public class MathCourseFactory extends CourseFactory {
    @Override
    public INote createNote() {
        super.init();
        return new MathNoteImpl();
    }

    @Override
    public IAnswer createAnswer() {
        return new MathAnswerImpl();
    }
}
```

客户端使用：

```java
public class Test {

    public static void main(String[] args) {
        CourseFactory factory = new MathCourseFactory();
        factory.createNote().edit();
        factory.createAnswer().speak();
    }
}
输出：
初始化参数
写数学笔记
回答数学问题
```

**抽象工厂模式的优点**

- 具体产品在应用层代码隔离，无须关系创建细节
- 将一个系列的产品族统一到一起创建

**抽象工厂模式的优点**

- 规定了所有可能被创建的产品集合，产品族扩展新的产品困难，需要修改抽象工厂的接口
- 增加了系统的抽象性和理解难度

**适用范围**

- 强调一系列相关的产品对象一起使用，创建对象需要大量重复代码
- 客户端不依赖于产品类如何被创建、实现等细节



**简单工厂、工厂方法、抽象工厂三者的理解**

> 在一些简单场景，且未来可能不发生变化或变化较少的情况下使用简单工厂；
>
> 较复杂的情况下使用工厂方法；
>
> 抽象工厂需要结合业务理解和发展来考虑的，在设计和开发期间比较难考虑产品的未来发展，通常使用工厂方法模式即可；面对已有的并且有大量重复代码可以使用抽象工厂模式进行代码优化。

## 单例模式

> 单例模式能够确保某一个类只有一个实例，并提供一个全局访问点。单例隐藏了所有的构造方法，属于创建型模式。

### 饿汉式单例

一个简单的饿汉式单例，在类初始化的时候创建。

```java
public class HungrySingleton {

    private static final HungrySingleton hungrySingleton = new HungrySingleton();

    public HungrySingleton() {
    }

    public static HungrySingleton getInstance() {
        return hungrySingleton;
    }
}
```

优点：执行效率高，性能高，没有任何的锁

缺点：某些情况下，会造成浪费内存

### 懒汉式单例 

#### 线程不安全懒汉式

一个简单的饿汉式单例，需要的时候才创建实例。

```java
public class LazySimpleSingleton {

    private static LazySimpleSingleton instance;

    private LazySimpleSingleton() {
    }

    public static LazySimpleSingleton getInstance() {
        if (instance == null) {
            instance = new LazySimpleSingleton();
        }
        return instance;
    }
}
```

优点：节省了内存

缺点：线程不安全



线程不安全是如何体现的，示例:

```java
// 实现一个线程类
public class ExecutorThread implements Runnable {
    @Override
    public void run() {
        LazySimpleSingleton instance = LazySimpleSingleton.getInstance();
        System.out.println(Thread.currentThread().getName() + ":" + instance);
    }
}

// 测试方法
public class LazySimpleSingletonTest {

    public static void main(String[] args) {
        Thread t1 = new Thread(new ExecutorThread());
        Thread t2 = new Thread(new ExecutorThread());
        t1.start();
        t2.start();
        System.out.println("执行结束");
    }
}
```

出现两种运行结果：

![](.\pics\线执行结果相同.png)



![](./pics/线执行结果不同.png)

- 结果出现同一个实例
  1. 正常顺序执行
  2. 后者覆盖前者

- 出现不同的实例
  1. 同时进入条件，按顺序返回

原因是创建实例时**`instance = new LazySimpleSingleton();`**不是一个原子类操作，存在线程风险。

#### synchronized安全懒汉式单例

那么我们只要给创建实例的方法加一个synchronized关键字就可以解决线程风险的问题：

```java
public class LazySimpleSingleton {
	
    private synchronized static LazySimpleSingleton instance;

    private LazySimpleSingleton() {
    }

    public static LazySimpleSingleton getInstance() {
        if (instance == null) {
            instance = new LazySimpleSingleton();
        }
        return instance;
    }
}
```

此时饿汉式单例能够节省内存，同时线程安全；但是加锁后有明显的性能瓶颈！



优化的第一个思路是降低锁的粒度，由方法级粒度到代码级粒度

```java
public class LazyDoubleCheckSimpleSingleton {

    private static LazyDoubleCheckSimpleSingleton instance;

    private LazyDoubleCheckSimpleSingleton() {
    }

    public  static LazyDoubleCheckSimpleSingleton getInstance() {
        synchronized(LazyDoubleCheckSimpleSingleton.class){
            if (instance == null) {
                instance = new LazyDoubleCheckSimpleSingleton();
            }
        }
        return instance;
    }
}
```

锁粒度的缩小并没有解决核心问题—多个线程每次同时获取实例时都会阻塞；进一步优化将阻塞到第一次创建实例时，因为在instance不为空的时候没必要阻塞，会跳过实例化的过程。

```java
public class LazyDoubleCheckSimpleSingleton {

    private static LazyDoubleCheckSimpleSingleton instance;

    private LazyDoubleCheckSimpleSingleton() {
    }

    public static LazyDoubleCheckSimpleSingleton getInstance() {
        if (instance == null) {
            synchronized (LazyDoubleCheckSimpleSingleton.class) {
                instance = new LazyDoubleCheckSimpleSingleton();
            }
        }
        return instance;
    }
}
```

如上代码，只有在实例不等于空的时候，才会阻塞，这样大大降低了阻塞的概率。但同时引发了另一个问题，线程1和线程2同时执行到synchronized代码块时，线程1获得CPU执行权成功new了新实例，接着线程2获取CPU执行权将又会执行一遍new实例，此时线程2获取的新实例会覆盖线程1获取的实例。起初引入synchronized关键字是为了解决重复创建的问题，但是有了性能瓶颈，优化着又回到了原点。

#### 双重检查锁单例

此时可以用双重检查锁同时解决以上问题：

```java
public class LazyDoubleCheckSimpleSingleton {

    private static LazyDoubleCheckSimpleSingleton instance;

    private LazyDoubleCheckSimpleSingleton() {
    }

    public static LazyDoubleCheckSimpleSingleton getInstance() {
        // 检查是否需要阻塞
        if (instance == null) {
            synchronized (LazyDoubleCheckSimpleSingleton.class) {
                // 检查是否还要创建单例
                if (instance == null) {
                    instance = new LazyDoubleCheckSimpleSingleton();
                }
            }
        }
        return instance;
    }
}
```

双重检查锁解决了线程不安全问题，同时大大优化了性能问题；可它也还是有问题的，线程还有个指令重排序的问题：创建对象实例时，会分为三步：

1. 分配对象内存
2. 调用构造器方法，执行初始化
3. 将对象引用赋值给变量

虚拟机实际运行时，为优化程序性能可能发生重排序。步骤 2,3 可能发生重排序，但是并不会重排序 1 的顺序。也就是说 1 这个指令都需要先执行，因为 2,3 指令需要依托 1 指令执行结果。在单例环境种，不会影响执行结果，但是多线程可能会带来一些问题：

|      | 线程1      | 线程2                      |
| ---- | ---------- | -------------------------- |
| t1   | 分配内存   |                            |
| t2   | 变量赋值   |                            |
| t3   |            | 判断对象是否为null         |
| t4   |            | 由于对象不为null，访问对象 |
| t5   | 初始化对象 |                            |

上面双重检查锁中，如果线程 1 获取到锁进入创建对象实例，这个时候发生了指令重排序。当线程1 执行到 t3 时刻，线程 2 刚好进入，由于此时对象已经不为 Null，所以线程 2 可以自由访问该对象。然后该对象还未初始化，所以线程 2 访问时将会发生异常。

#### 完善的双重检查锁

双重检查锁定模式需要需要使用 `volatile`。`volatile`主要包含两个功能。

1. 保证可见性。使用 `volatile` 定义的变量，将会保证对所有线程的可见性。
2. **禁止指令重排序优化。**

```java
public class LazyDoubleCheckSimpleSingleton {
    /**
     * volatile解决指令重排序的问题
     */
    private volatile static LazyDoubleCheckSimpleSingleton instance;

    private LazyDoubleCheckSimpleSingleton() {
    }

    public static LazyDoubleCheckSimpleSingleton getInstance() {
        // 检查是否需要阻塞
        if (instance == null) {
            synchronized (LazyDoubleCheckSimpleSingleton.class) {
                // 检查是否还要创建单例
                if (instance == null) {
                    instance = new LazyDoubleCheckSimpleSingleton();
                }
            }
        }
        return instance;
    }
}
```

 双重检查锁：

	- 性能高，线程安全
	- 代码可读性难度加大，不够优雅

如何实现一个性能高，线程又安全，且优雅的单例？

#### Java内部类创建单例

```
Java特性：静态内部类在初始化的时候不会被读取，在使用的时候才会加载
```

```java
public class LazyStaticInnerClassSingleton {

    private LazyStaticInnerClassSingleton(){}

    private static LazyStaticInnerClassSingleton getInstance(){
        return LazyHolder.INSTANCE;
    }

    /**
     * 静态内部类
     * 看似是饿汉式单例，实际是懒汉式单例
     * Java特性：静态内部类在初始化的时候不会被读取，在使用的时候才会加载
     * LazyStaticInnerClassSingleton.class
     * LazyStaticInnerClassSingleton$LazyHolder.class
     *
     * 优点：写法优雅，性能高，避免了内存浪费，线程安全
     * 缺点：能够被反射破坏
     */
    private static class LazyHolder{
        private static final  LazyStaticInnerClassSingleton INSTANCE = new LazyStaticInnerClassSingleton();
    }
}
```

利用Java特性实现了看似完美的单例，同时满足性能高、线程安全且足够优雅的单例；但这种方式还有一个隐患，能够被反射破坏。

```java
public class ReflectTest {

    public static void main(String[] args) {
        try {
            Class<?> clazz = LazyStaticInnerClassSingleton.class;
            Constructor declaredConstructor = clazz.getDeclaredConstructor();
            declaredConstructor.setAccessible(true);
            Object instance1 = declaredConstructor.newInstance();
            Object instance2 = declaredConstructor.newInstance();
            System.out.println(instance1 == instance2);
        } catch (Exception e) {
            e.printStackTrace();
        }
    }
}

输出结果：false
```

足以可见利用内部静态类的方式会被反射所破坏...是否可以解决这问题？在构造方法种判断是否存在单例可以解决反射破坏的问题

```java
public class LazyStaticInnerClassSingleton {

    private LazyStaticInnerClassSingleton(){
        // 解决反射破坏单例的问题
        if(LazyHolder.INSTANCE != null){
            throw new RuntimeException("不允许非法访问！");
        }
    }

    private static LazyStaticInnerClassSingleton getInstance(){
        return LazyHolder.INSTANCE;
    }

    /**
     * 静态内部类
     * 看似是饿汉式单例，实际是懒汉式单例
     * Java特性：静态内部类在初始化的时候不会被读取，在使用的时候才会加载
     * LazyStaticInnerClassSingleton.class
     * LazyStaticInnerClassSingleton$LazyHolder.class
     *
     * 优点：写法优雅，性能高，避免了内存浪费，线程安全
     * 缺点：能够被反射破坏
     */
    private static class LazyHolder{
        private static final  LazyStaticInnerClassSingleton INSTANCE = new LazyStaticInnerClassSingleton();
    }
}
```

在构建方法种抛出异常，又回到代码阅读比较困难，不够优雅的问题。

### 注册式单例

在《Java Effective》里面推荐使用枚举式单例。

```java
public enum EnumSingleton {
    /**
     * 全局唯一单例
     */
    INSTANCE;

    private Object data;

    public Object getData() {
        return data;
    }

    public void setData(Object data) {
        this.data = data;
    }

    public static EnumSingleton getInstance() {
        return INSTANCE;
    }
}


public class EnumSingletonTest {

    public static void main(String[] args) {
         // 使用枚举类操作单例
        EnumSingleton instance = EnumSingleton.getInstance();
        // 设置单例
        instance.setData(new Object());
        // 获取单例
        Object data = instance.getData();
        System.out.println(data);
        
        try {
//            Enum
            Class<?> clazz = EnumSingleton.class;
            Constructor declaredConstructor = clazz.getDeclaredConstructor(String.class, int.class);
            declaredConstructor.setAccessible(true);
            Object instance1 = declaredConstructor.newInstance();
            Object instance2 = declaredConstructor.newInstance();
            System.out.println(instance1 == instance2);
        } catch (Exception e) {
            e.printStackTrace();
        }
    }
}
```

这时候使用反射获取单例，同样提示报错

![](./pics/枚举单例失败.png)

原因是枚举类继承enum，内部做了限制：

![](./pics/枚举限制反射破坏单例.png)

当修饰符是enum时，会抛出异常，不能使用反射创建单例。

*Enum类是如何保证单例的创建？*

Enum类有一个valuesOf的方法，可以通过传入枚举常量值获取实例

![](.\pics\枚举1.png)

enumConstantDirectory是一个Map，key是枚举常量名，value是实例。(类似于IOC容器)

![](.\pics\枚举2.png)

这样可以基本得出结论，注册式单例是通过map保存实例，并确保其唯一性；map中可以同时存放多个实例，其本质也是属于饿汉式单例

### 单例模式小结

各种创建单例模式的对比：

| 类型   | 方式               | 优点                           | 缺点                       | 说明                     |
| ------ | ------------------ | ------------------------------ | -------------------------- | ------------------------ |
| 饿汉式 | 简单饿汉式         | 执行效率高，性能高，无锁       | 某些情况下，会造成浪费内存 |                          |
|        | 注册式单例         | 执行效率高，性能高，无锁，优雅 | 某些情况下，会造成浪费内存 | 通过map容器实现          |
| 懒汉式 | 简单饿汉式         | 节省内存                       | 线程不安全                 |                          |
|        | synchronized饿汉式 | 节省内存，同时线程安全         | 存在明显性能瓶颈           |                          |
|        | 双重检查锁         | 性能高，线程安全               | 代码不够优雅               | 使用volatile排除指令重排 |

**单例模式的优点**：

1. 单例模式在内存中只有一个实例，减少了内存开支
2. 单例模式避免对资源的多重占用，例如一个写文件的动作，由于只有一个实例存在内存中，避免对同一个资源文件的同时写操作
3. 单例模式可以在系统设置全局的访问点，优化和共享资源访问

**单例模式的缺点**：

1. 单例模式没有接口，扩展困难。如果要扩展，必须修改代码

**实现单例**：

	1. 私有化构造器
	2. 保证线程安全
	3. 延迟加载
	4. 防御反射破坏单例

单例模式有着两大类实现方式，追求性能且开发简单的是饿汉式单例，可能会牺牲内存；既希望性能高且安全，建议使用双重检查锁单例。

## 原型模式

> 原型模式是指原型实例指定创建对象的种类，并且通过**拷贝**这些原型创建新的对象。调用者不需要知道任何创建细节，不调用构造函数；属于创建型模式。

### 适用场景

在某些业务场景下，需要复用一个类进行操作，通常会使用构造方法或者getter和setter去复制一份：

```java
@Data
public class ExamPaper {
    private String examinationPaperId;//试卷主键
    private String leftTime;//剩余时间
    private String organizationId;//单位主键
    private String id;//考试主键
    private String examRoomId;//考场主键
    private String userId;//用户主键
    private String specialtyCode;//专业代码
    private String positionCode;//报考岗位
    private String gradeCode;//报考等级
    private String examStartTime;//考试开始时间
    private String examEndTime;//考试结束时间
    private String singleSelectionImpCount;//单选选题重要数量
    private String multiSelectionImpCount;//多选题重要数量
    private String judgementImpCount;//判断题重要数量
    private String examTime;//考试时长
    private String fullScore;//总分
    private String passScore;//及格分
    private String userName;//学员姓名
    private String score;//考试得分
    private String result;//是否及格
    private String singleOkCount;//单选题答对数量
    private String multiOkCount;//多选题答对数量
    private String judgementOkCount;//判断题答对数量

    /**
     * 硬编码实现
     */
    public ExamPaper copy(){
        ExamPaper examPaper = new ExamPaper();
        //剩余时间
        examPaper.setLeftTime(this.getLeftTime());
        //单位主键
        examPaper.setOrganizationId(this.getOrganizationId());
        //考试主键
        examPaper.setId(this.getId());
        //用户主键
        examPaper.setUserId(this.getUserId());
        //专业
        examPaper.setSpecialtyCode(this.getSpecialtyCode());
        //岗位
        examPaper.setPositionCode(this.getPositionCode());
        //等级
        examPaper.setGradeCode(this.getGradeCode());
        //考试开始时间
        examPaper.setExamStartTime(this.getExamStartTime());
        //考试结束时间
        examPaper.setExamEndTime(this.getExamEndTime());
        //单选题重要数量
        examPaper.setSingleSelectionImpCount(this.getSingleSelectionImpCount());
        //多选题重要数量
        examPaper.setMultiSelectionImpCount(this.getMultiSelectionImpCount());
        //判断题重要数量
        examPaper.setJudgementImpCount(this.getJudgementImpCount());
        //考试时间
        examPaper.setExamTime(this.getExamTime());
        //总分
        examPaper.setFullScore(this.getFullScore());
        //及格分
        examPaper.setPassScore(this.getPassScore());
        //学员姓名
        examPaper.setUserName(this.getUserName());
        //分数
        examPaper.setScore(this.getScore());
        //单选答对数量
        examPaper.setSingleOkCount(this.getSingleOkCount());
        //多选答对数量
        examPaper.setMultiOkCount(this.getMultiOkCount());
        //判断答对数量
        examPaper.setJudgementOkCount(this.getJudgementOkCount());

        return examPaper;
    }

    @Override
    public String toString() {
        return "ExamPaper{" +
                "examinationPaperId='" + examinationPaperId + '\'' +
                ", leftTime='" + leftTime + '\'' +
                ", organizationId='" + organizationId + '\'' +
                ", id='" + id + '\'' +
                ", examRoomId='" + examRoomId + '\'' +
                ", userId='" + userId + '\'' +
                ", specialtyCode='" + specialtyCode + '\'' +
                ", positionCode='" + positionCode + '\'' +
                ", gradeCode='" + gradeCode + '\'' +
                ", examStartTime='" + examStartTime + '\'' +
                ", examEndTime='" + examEndTime + '\'' +
                ", singleSelectionImpCount='" + singleSelectionImpCount + '\'' +
                ", multiSelectionImpCount='" + multiSelectionImpCount + '\'' +
                ", judgementImpCount='" + judgementImpCount + '\'' +
                ", examTime='" + examTime + '\'' +
                ", fullScore='" + fullScore + '\'' +
                ", passScore='" + passScore + '\'' +
                ", userName='" + userName + '\'' +
                ", score='" + score + '\'' +
                ", result='" + result + '\'' +
                ", singleOkCount='" + singleOkCount + '\'' +
                ", multiOkCount='" + multiOkCount + '\'' +
                ", judgementOkCount='" + judgementOkCount + '\'' +
                '}';
    }
}
```

类的字段比较多的时候，也可以使用反射去实现：

```java
// 反射实现类拷贝
public class BeanUtils {
    public static Object copy(Object protorype) {
        Class clazz = protorype.getClass();
        Object returnValue = null;
        try {
            returnValue = clazz.newInstance();
            for (Field field : clazz.getDeclaredFields()) {
                field.setAccessible(true);
                field.set(returnValue, field.get(protorype));
            }
        } catch (Exception e) {
            e.printStackTrace();
        }
        return returnValue;
    }
}
```

反射简化了代码，不过其本质上还是set和get。



**原型模式不通过new关键字，而是通过clone方法去复制一份，通过方法创建的对象能够保留原来的值。**

适用场景：

1. 类初始化消耗资源较多
2. new产生的一个对象需要非常繁琐的过程（数据准备、访问权限等）
3. 构造函数比较复杂
4. 循环体中产生大量对象时

原型模式标准写法是新建一个原型接口类，定义一个克隆接口；在需要复制的类上去实现这个接口类，并重写克隆方法；这样客户端在调用的时候只需要通过克隆方法就可以获取一个新的对象。

```java
// 原型接口类，包含一个克隆方法
public interface IPrototype<T> {
    T clone();
}

// 类实现原型接口，并重写克隆方法
public class PrototypeImpl implements IPrototype<PrototypeImpl> {
    private int age;
    private String name;

    public int getAge() {
        return age;
    }

    public void setAge(int age) {
        this.age = age;
    }

    public String getName() {
        return name;
    }

    public void setName(String name) {
        this.name = name;
    }

    @Override
    public PrototypeImpl clone() {
        PrototypeImpl prototypeImpl = new PrototypeImpl();
        prototypeImpl.setAge(this.age);
        prototypeImpl.setName(this.name);
        return prototypeImpl;
    }

    @Override
    public String toString() {
        return "prototypeImpl{" +
                "age=" + age +
                ", name='" + name + '\'' +
                '}';
    }
}

//3.适用clone方法
public class Client {
    public static void main(String[] args) {
        //创建原型对象
        PrototypeImpl prototype = new PrototypeImpl();
        prototype.setAge(18);
        prototype.setName("Tom");
        System.out.println(prototype);

        //拷贝原型对象
        PrototypeImpl cloneType = prototype.clone();
        System.out.println(cloneType);
    }

}

```

原型模式的核心是克隆复制方法；复制有两种克隆，一种是浅克隆，一种是深克隆。

### 浅克隆

在上面的示例中，如果类属性很多的话，那么要一个个的set和get，这种硬编码的方式就会很繁琐。JDK中有一个现成的API，实现Cloneable接口，那么就可以使用它的clone方法：

```java
// 继承Cloneable接口，通过clone方法来实现克隆
@Data
public class PrototypeImpl implements Cloneable {
    private int age;
    private String name;
    private List<String> hobbies;

    @Override
    public PrototypeImpl clone() {
        try {
            return (PrototypeImpl)super.clone();
        } catch (CloneNotSupportedException e) {
            e.printStackTrace();
        }
        return null;
    }

    @Override
    public String toString() {
        return "PrototypeImpl{" +
                "age=" + age +
                ", name='" + name + '\'' +
                ", hobbies=" + hobbies +
                '}';
    }
}

//客户端调用
public class Client {
    public static void main(String[] args) {
        //创建原型对象
        PrototypeImpl prototype = new PrototypeImpl();
        prototype.setAge(18);
        prototype.setName("Tom");
        List<String> hobbies = new ArrayList<>();
        hobbies.add("编程");
        hobbies.add("看书");
        prototype.setHobbies(hobbies);

        //拷贝原型对象
        PrototypeImpl cloneType = prototype.clone();
        cloneType.getHobbies().add("加班");
        System.out.println("原型对象" + prototype);
        System.out.println("克隆对象" + cloneType);
        System.out.println(cloneType == prototype);

        System.out.println(prototype.getHobbies() == cloneType.getHobbies());
    }

}

输出结果：
原型对象PrototypeImpl{age=18, name='Tom', hobbies=[编程, 看书, 加班]}
克隆对象PrototypeImpl{age=18, name='Tom', hobbies=[编程, 看书, 加班]}
false
true
```

在`PrototypeImpl`中新增了爱好属性，为`List`类型。在复制的时候，希望克隆出来的对象和原型对象是两个独立的对象，不应该再有联系。但是输出结果中，发现改变了拷贝对象，原型对象也随之变化了。

通过第一个对比结果为true，能够确认`cloneTyp`e和`protoType`确实为两个不同的对象，结果为false；但是他们的属性hobbies，却是指向同一个地址的。也就是说**只是完整复制了值类型数据，没有赋值引用对象**，这就是浅克隆。下面通过深克隆来解决浅克隆的问题，让引用对象不再指向原来对象。

### 深克隆

在浅克隆的基础上继续改造，新增一个`deepClone`方法：

```java
// 注意序列化
@Data
public class PrototypeImpl implements Cloneable, Serializable {
    private int age;
    private String name;
    private List<String> hobbies;

    @Override
    public PrototypeImpl clone() {
        try {
            return (PrototypeImpl) super.clone();
        } catch (CloneNotSupportedException e) {
            e.printStackTrace();
        }
        return null;
    }

    // 通过流实现深克隆
    public PrototypeImpl deepClone() {
        try {
            ByteArrayOutputStream byteArrayOutputStream = new ByteArrayOutputStream();
            ObjectOutputStream objectOutputStream = new ObjectOutputStream(byteArrayOutputStream);
            objectOutputStream.writeObject(this);

            ByteArrayInputStream byteArrayInputStream = new ByteArrayInputStream(byteArrayOutputStream.toByteArray());
            ObjectInputStream objectInputStream = new ObjectInputStream(byteArrayInputStream);
            return (PrototypeImpl) objectInputStream.readObject();
        } catch (Exception e) {
            e.printStackTrace();
            return null;
        }
    }

    @Override
    public String toString() {
        return "PrototypeImpl{" +
                "age=" + age +
                ", name='" + name + '\'' +
                ", hobbies=" + hobbies +
                '}';
    }
}

// 客户端调用
public class Client {
    public static void main(String[] args) {
        //创建原型对象
        PrototypeImpl prototype = new PrototypeImpl();
        prototype.setAge(18);
        prototype.setName("Tom");
        List<String> hobbies = new ArrayList<>();
        hobbies.add("编程");
        hobbies.add("看书");
        prototype.setHobbies(hobbies);

        //拷贝原型对象
        PrototypeImpl cloneType = prototype.deepClone();
        cloneType.getHobbies().add("加班");
        System.out.println("原型对象" + prototype);
        System.out.println("克隆对象" + cloneType);
        System.out.println(cloneType == prototype);

        System.out.println(prototype.getHobbies() == cloneType.getHobbies());
    }
}

输出结果：
原型对象PrototypeImpl{age=18, name='Tom', hobbies=[编程, 看书]}
克隆对象PrototypeImpl{age=18, name='Tom', hobbies=[编程, 看书, 加班]}
false
false   
```

此时深克隆得到了期望的结果，引用对象类型不再指向原来对象。

### 源码中的应用

使用`ArrayList`时默认构造容量大小时10，当`ArrayList`中的元素超过10个以后，会重新分配内存空间。这其中就会进行一次克隆操作，将原来的元素拷贝到新的内存空间中

![](.\pics\ArrayList扩容复制.png)

同理HashMap中的扩容复制

![](.\pics\hashMap扩容复制.png)



## 建造者模式

> 建造者模式是将一个复杂对象的构建过程与它的表示分离，使同样的构建过程可以创建不同的表示，属于创建型模式。使用建造者模式对于用户而言只需指定需要创建的类型就可以获得创建对象，创造过程及细节不需要了解。

建造者模式适用于创建对象需要很多步骤，但是步骤的顺序不一定固定。如果一个对象有很复杂的内部结构，可以将对象的创建和使用进行分离。

### 建造者模式的适用场景

建造者模式适用于，当需求变化时，组成产品的各个零件经常发生猛烈变化，但是它们的组合方式全相对稳定。

1. 相同方法，不同的执行顺序，产生不同的结果
2. 多个部件或零件，都可以装配到一个对象中，但是结果又不相同
3. 产品类非常复杂，产品类中的不同调用顺序产生不同的结果
4. 初始化一个对象特别复杂，参数多而且很多大都具有默认值时。

### 建造者模式的写法

以课程为例，一个课程有ppt、视频、笔记、课后作业等组成，这些内容的顺序可以任意调换，可以部分属性有部分属性没有。

```java
// 产品类-课程
@Data
public class Course {

    private String name;

    private String ppt;

    private String video;

    private String note;

    private String homework;

    @Override
    public String toString() {
        return "Course{" +
                "name='" + name + '\'' +
                ", ppt='" + ppt + '\'' +
                ", video='" + video + '\'' +
                ", note='" + note + '\'' +
                ", homework='" + homework + '\'' +
                '}';
    }

}

// course的建造者，将构造过程封装起来，构造步骤由用户决定
public class CourseBuilder {

    private Course course = new Course();

    public CourseBuilder addName(String name) {
        course.setName(name);
        return this;
    }

    public CourseBuilder addPpt(String ppt) {
        course.setPpt(ppt);
        return this;
    }

    public CourseBuilder addVideo(String video) {
        course.setVideo(video);
        return this;
    }

    public CourseBuilder addNote(String note) {
        course.setNote(note);
        return this;
    }

    public CourseBuilder addHomework(String homework) {
        course.setHomework(homework);
        return this;
    }

    public Course builder() {
        return course;
    }
}

//测试类
public class Test {
    public static void main(String[] args) {
        CourseBuilder builder = new CourseBuilder()
                .addName("设计模式").addPpt("wiki上的链接")
                .addNote("Eamon的笔记");
        System.out.println(builder.builder());
    }
}

```

建造者模式通常是采用链式编程的方法构造对象。



### 源码中的引用

StringBuilder的append方法

![](.\pics\StringBuilder应用建造者模式.png)

还有SQL的构造方法QueryRuleSqlBuilder、Mybatis中的SqlSessionFactoryBuilder中的builder方法等。

**建造者模式优点**：

- 封装性好，创建和使用分离
- 扩展性好，建造类之间独立、一定程度解耦

**建造者模式缺点**：

- 产生多余的Builder对象
- 产品内部发生变化，建造者都要修改，成本较大

建造者和工厂模式都属于创建者，但它们是有区别的：**工厂模式注重的是整体对象的创建方法，而建造者模式注重的是对象的创建过程，创建对象的过程方法可以在创建时自由调用**。



## 代理模式

> 代理模式是指为其他对象提供一种代理，以控制对这个对象的访问。代理对象再客户端和目标对象之间起到**中介作用**。属于结构性设计模式。

### 适用场景

租房中介、婚介、明星经纪人、非侵入式日志监听等，都是代理模式的实际体现。当无法或不想直接访问某个对象存在困难时，可以通过代理对象来间接访问。适用代理主要由两个目的：**一是保护目标对象，二是增强目标对象**。

代理模式通常分为两大类，一个是静态代理，一个是动态代理。

### 静态代理

有一个明星(被代理类)，通常人们都见不到他，也联系不到他。粉丝们只能通过经纪人（代理类）传达自己的爱意，经纪人（代理）就可以对粉丝信息筛选过滤，选择一些有用的给明星，也防止一些无脑粉丝伤害明星。

这时候有人要和明星进行商务合作，同样是通过和经纪人的谈判。经纪人如何知道明星会接哪些合作、有什么喜好呢？因为经纪人和明星实现了同样的接口或者抽象类，经纪人知道明星的所有。经纪人为明星接了一个跳舞的演出活动，经纪人知道明星会跳舞(继承了这个方法)，具体执行还是明星去跳舞。

明星接口：

```java
public interface StarInterface {
    void  dance();
}
```

周杰伦：

```java
public class JayChou implements StarInterface{
    @Override
    public void dance() {
        System.out.println("I am JayChou,快使用双节棍，哼哼哈嘿！");
    }
}
```

经纪人：

```java
public class Proxy implements StarInterface{
    private StarInterface star = new JayChou();

    public Proxy(StarInterface _star){
        this.star = _star;
    }

    @Override
    public void dance() {
        this.before();
        star.dance();
        this.after();
    }

    private void after() {
        System.out.println("演出结束，支付尾款30w");
    }

    private void before() {
        System.out.println("演出之前，付定金20w");
    }
}
```

客户：

```java
public class Client {
    public static void main(String[] args) {
        StarInterface jay = new JayChou();
        Proxy proxy = new Proxy(jay);
        proxy.dance();
    }
}

输出：
演出之前，付定金20w
I am JayChou,快使用双节棍，哼哼哈嘿！
演出结束，支付尾款30w
```

静态代理的缺点：

如果有这样的需求，某个程序猿为了脱单，给心仪女神请了20个明星为他助威。有的明星唱歌，有的明星跳舞，有的明星说相声…这时候需要代理的方法就多了，唱歌、跳舞、相声等等。那么怎么解决呢？

方案一：为这些方法创建不同的代理类
方案二：创建一个Proxy，实现所有的明星接口。

显然方案一会让代码有大量重复，第二种方案会使得Proxy极为复杂，如果两个明星都会唱歌，还要加入不同的判断逻辑。

### 动态代理

动态代理可以解决静态代理的缺点，动态代理可以在运行时，动态生成一个持有具体明星、并实现代理接口的Proxy，同时注入我们相同的扩展逻辑。动态代理就是上面的方案一的进一步抽象和封装，不同的是proxy的创建都是自动的而且在运行期通过反射生成的，减少了代码的重复。

#### JDK动态代理

明星接口```StarInterface```和周杰伦```JayChou```不变。构建一个Handler类来实现```InnovationHandler```接口

```java
public class ProxyHandler implements InvocationHandler {
    private Object obj;
    public ProxyHandler(Object _obj){
        this.obj = _obj;
    }

    @Override
    public Object invoke(Object proxy, Method method, Object[] args) throws Throwable {
        this.before();
        method.invoke(obj, args);
        this.after();
        return null;
    }

    private void before() {
        System.out.println("演出之前，支付定金20w");
    }

    private void after() {
        System.out.println("演出结束，支付尾款30w");
    }
}
```

执行动态代理

```java
public class Client2 {
    public static void main(String[] args) {
        StarInterface jay = new JayChou();
        InvocationHandler handler = new ProxyHandler(jay);
        StarInterface proxyStar = (StarInterface) Proxy.newProxyInstance(jay.getClass().getClassLoader(), jay.getClass().getInterfaces(), handler);
        proxyStar.dance();
    }
}
```

通过Proxy类的静态方法返回一个接口的代理实例，针对不同的代理类，传入相应的代理程序控制器```InvocationHandler```。如果再来一个明星林俊杰，如：

```java
public class JJ implements  StarInterface{
    @Override
    public void dance() {
        System.out.println("我是林俊杰，不擅长跳舞，但我是行走的唱片机！");
    }
}
```

执行过程：

```java
public class Client2 {
    public static void main(String[] args) {
        StarInterface jay = new JayChou();
        StarInterface jj = new JJ();

        InvocationHandler handler = new ProxyHandler(jay);
        InvocationHandler jjHandler = new ProxyHandler(jj);

        StarInterface proxyJay = (StarInterface) Proxy.newProxyInstance(jay.getClass().getClassLoader(), jay.getClass().getInterfaces(), handler);
        StarInterface proxyJJ = (StarInterface) Proxy.newProxyInstance(jj.getClass().getClassLoader(), jj.getClass().getInterfaces(), jjHandler);

        proxyJay.dance();
        proxyJJ.dance();
    }
}

输出：
演出之前，支付定金20w
快使用双节棍，哼哼哈嘿！
演出结束，支付尾款30w
演出之前，支付定金20w
我不会跳舞，但是我唱歌好听！
演出结束，支付尾款30w
```

#### Cglib动态代理

与上节同样的例子，适用CGLIB实现

```java
// cglib实现动态代理
public class CglibProxyHandler implements MethodInterceptor {

    public Object getInstance(Class<?> clazz) {
        Enhancer enhancer = new Enhancer();
        enhancer.setSuperclass(clazz);
        enhancer.setCallback(this);
        return enhancer.create();
    }

    private void before() {
        System.out.println("演出之前，支付定金20w");
    }

    private void after() {
        System.out.println("演出结束，支付尾款30w");
    }

    @Override
    public Object intercept(Object o, Method method, Object[] objects, MethodProxy methodProxy) throws Throwable {
        this.before();
        Object result = methodProxy.invokeSuper(o, objects);
        this.after();
        return result;
    }
}


public class Client {

    public static void main(String[] args) {
        // CGLIB代理的目标对象不需要实现任何接口，它是通过动态继承目标对象实现动态代理
        JayChou jayChou = (JayChou) new CglibProxyHandler().getInstance(JayChou.class);
        jayChou.dance();
    }
}
```



### 代理之间的区别

静态代理的代表为AspectJ；动态代理则以Spring AOP为代表。

1. AspectJ是静态代理的增强，所谓静态代理，就是会在编译阶段生成代理类，他会在编译阶段将AspectJ(切面)织入到Java字节码中，运行的时候就是增强之后的代理对象。

2. Spring AOP使用的动态代理，所谓的动态代理就是说AOP框架不会去修改字节码，而是每次运行时在内存中临时为方法生成一个AOP对象，这个AOP对象包含了目标对象的全部方法，并且在特定的切点做了增强处理，并回调原对象的方法。

   Spring AOP中的动态代理主要有两种方式，JDK动态代理和CGLIB动态代理：

   1. JDK动态代理**只提供接口的代理，不支持类的代理**。核心是InvocationHandler接口和Proxy类，InvocationHandler 通过invoke()方法反射来调用目标类中的代码，动态地将横切逻辑和业务编织在一起；接着，Proxy利用InvocationHandler动态创建一个符合某一接口的的实例, 生成目标类的代理对象。
   2. 如果代理类没有实现 InvocationHandler 接口，那么Spring AOP会选择使用CGLIB来动态代理目标类。CGLIB（Code Generation Library），是一个代码生成的类库，可以在运行时动态的生成指定类的一个子类对象，并覆盖其中特定方法并添加增强代码，从而实现AOP。**CGLIB是通过继承的方式做的动态代理**，因此如果**某个类被标记为final，那么它是无法使用CGLIB做动态代理的**

3. 静态代理的效率相对动态代理来说相对高一些，但是静态代理代码冗余大，一单需要修改接口，代理类和委托类都需要修改。



**JDK动态代理和CGLIB代理的主要区别**

JDK动态代理实现步骤：

1. 动态生成源码.java文件
2. java文件输出到磁盘，保存为文件$Proxy0.java文件
3. 生成的.java文件编译成$Proxy0.class文件
4. 把生成的.class文件加载到JVM中
5. 返回新的代理对象

区别：

- JDK采用实现的方式，必须要求代理的目标对象一定要实现一个接口；CGLIB采用继承的方式，覆盖父类的方法。**思想都是一样的，通过生成字节码，重新组成一个新的类**
- JDK代理对于用户而言，依赖更强，调用更复杂；CGLIB对目标类没有任何要求
- JDK生成逻辑简单，执行效率要低，因为每次都要用到反射；CGLIB底层没有用到反射，适用的是FastClass机制(*为代理类和被代理类各生成一个类，这个类会为代理类或被代理类的方法分配一个index；将这个index当作入参，就可以直接定位到调用的方法并直接进行调用，省去了反射调用*)直接调用方法，因此效率更高，性能更好
- CGLIB有个坑，目标代理类不能由final修饰的方法，会忽略final修饰的方法。

### 代理的应用

- Mybatis使用cglib达到延迟加载的效果
- Mybatis使用JDK动态代理开发插件。Mybatis可编写的插件：ParameterHandler、ResultSetHandler、StatementHandler、Executor四种接口插件

### 代理优缺点

优点：

1. 代理模式能够将代理对象与真实被调用对象分离，一定程度上降低系统的耦合程度，易于扩展
2. 代理可以起到保护目标的作用
3. 代理可以增强目标对象的职责

缺点：

1. 代理模式会造成系统设计中类数目增加
2. 再客户端和目标类之间增加了代理对象，链路变长，请求处理速度变慢
3. 增加了系统的复杂度

## 门面模式

> 门面模式又叫外观模式，提供一个统一的接口，用来访问子系统中的一群接口。门面模式定义了一个高层接口，让子系统更容易适用；属于结构性模式。

### 适用场景

- 子系统越来越复杂，增加门面模式提供简单接口

- 构建多层系统结构，利用门面对象作为每层的入口，简化层间调用。

举个例子，每天逛论坛，进行签到以及发起有效讨论，可以获取积分，积分可以兑换礼品。如何去实现礼品的兑换。可以简略抽象为三个步骤

1. 校验积分以及仓库库存是否足够
2. 积分的扣减
3. 呼叫快递揽收，并接收快递单号信息

伪代码实现为：

```java
// 积分礼品类
public class GifInfo {

    private String name;

    public GifInfo(String name) {
        this.name = name;
    }

    public String getName() {
        return name;
    }

    public void setName(String name) {
        this.name = name;
    }
}

// 积分校验以及库存检验
public class QualifyService {

    public boolean isAvailable(GifInfo git) {
        System.out.println("校验" + git.getName() + "积分通过，库存通过");
        return true;
    }
}

// 积分支付子系统
public class PaymentService {

    public boolean pay(GifInfo git) {
        System.out.println("扣减" + git.getName() + " 积分成功");
        return true;
    }
}

// 快递子系统
public class ShippingService {

    public String delivery(GifInfo git) {
        System.out.println(git.getName() + "进入物流系统");
        String shippingNo = "666";
        return shippingNo;
    }
}

// 客户端调用
public class Client {

    public static void main(String[] args) {
        QualifyService qualifyService = new QualifyService();
        PaymentService paymentService = new PaymentService();
        ShippingService shippingService = new ShippingService();

        GifInfo gifInfo = new GifInfo("《设计模式精讲》");

        if (qualifyService.isAvailable(gifInfo)) {
            if (paymentService.pay(gifInfo)) {
                String delivery = shippingService.delivery(gifInfo);
                System.out.println("物流系统下单成功，物流单号是：" + delivery);
            }
        }
    }
}

输出结果：
校验《设计模式精讲》积分通过，库存通过
扣减《设计模式精讲》 积分成功
《设计模式精讲》进入物流系统
物流系统下单成功，物流单号是：666
```

如上的客户端调用必须了解每个子系统功能，挨个调用。如果适用门面模式：

```java
// 门面模式类
public class FacadeService {

    QualifyService qualifyService = new QualifyService();
    PaymentService paymentService = new PaymentService();
    ShippingService shippingService = new ShippingService();

    public void exchange(GifInfo gifInfo){
        if (qualifyService.isAvailable(gifInfo)) {
            if (paymentService.pay(gifInfo)) {
                String delivery = shippingService.delivery(gifInfo);
                System.out.println("物流系统下单成功，物流单号是：" + delivery);
            }
        }
    }
}

// 客户端调用
public class Client {

    public static void main(String[] args) {
        GifInfo gifInfo = new GifInfo("《设计模式精讲》");
        FacadeService facadeService = new FacadeService();
        facadeService.exchange(gifInfo);
    }
}

输出结果：
校验《设计模式精讲》积分通过，库存通过
扣减《设计模式精讲》 积分成功
《设计模式精讲》进入物流系统
物流系统下单成功，物流单号是：666
```

适用门面模式可以很好隐藏子系统的具体实现细节，既安全同时又降低客户端理解难度。如快递子系统里面还有调用各种不同快递的方法，获取用户个人信息等方法，是不适宜暴露给客户端。

生活中的例子：

> 如果把医院作为一个子系统，按照部门职能，这个系统可以划分为挂号、门诊、划价、化验、收费、取药等。看病的病人要与这些部门打交道，就如同一个子系统的客户端与一个子系统的各个类打交道一样，不是一件容易的事情。

> 首先病人必须先挂号，然后门诊。如果医生要求化验，病人必须首先划价，然后缴费，才可以到化验部门做化验。化验后再回到门诊室。

![img](https://www.runoob.com/wp-content/uploads/2018/07/1530601041-6113-.png)

解决这种不便的方法便是引进门面模式，医院可以设置一个接待员的位置，由接待员负责代为挂号、划价、缴费、取药等。这个接待员就是门面模式的体现，病人只接触接待员，由接待员与各个部门打交道。

![img](https://www.runoob.com/wp-content/uploads/2018/07/1530601040-5088-.png)

### 门面的应用

JdbcUtils

Mybatis中的Configuration

### 优缺点

**优点**

1. 简化了调用过程，无需深入了解子系统，以防给子系统带来风险
2. 减少系统依赖、松散耦合
3. 更好地划分访问层次，提高了安全性
4. 遵循迪米特法则，即最少知道法则

**缺点**

1. 当增加子系统和扩展子系统行为时，可能容易带来未知风险
2. 不符合开闭原则
3. 某些情况下可能违背单一职责原则

## 装饰器模式

> 装饰器模式也叫包装模式，是指在不改变原有对象的基础上将功能附加到对象上，提供了比继承更有弹性的替代方案。属于结构性模式

### 适用场景

1. 用于扩展一个类的功能或给一个类添加附加职责
2. 动态的给一个对象添加功能，这些功能可以再动态的撤销

装饰的通用类图：

![](.\pics\装饰器通用模式.png)

Component：抽象(接口)类

Decorator:装饰器抽象类，继承Component

ConcreteComponent:抽象Component的具体实现类

ConcreteDecoratorA:继承自Decorator的具体实现A类

ConcreteDecoratorB:继承自Decorator的具体实现B类

### 装饰器应用

早上上班前去买一个煎饼，煎饼有加鸡蛋、烤肠等，使用伪代码实现：

```java
// 煎饼
public class PanCake {

    protected String getMsg() {
        return "煎饼";
    }

    public int getPrice() {
        return 5;
    }
}

// 加鸡蛋的煎饼
public class PanCakeWithEgg extends PanCake {

    protected String getMsg() {
        return super.getMsg() + ",加1个鸡蛋";
    }

    public int getPrice() {
        return super.getPrice() + 1;
    }
}

// 加鸡蛋和烤肠的煎饼
public class PanCakeWithEggAndSauage extends PanCakeWithEgg {
    protected String getMsg() {
        return super.getMsg() + ",再+1根香肠";
    }

    public int getPrice() {
        return super.getPrice() + 2;
    }
}

// 客户端调用
public class Test {
    public static void main(String[] args) {
        PanCake panCake = new PanCake();
        System.out.println(panCake.getMsg() + ", 总价" + panCake.getPrice());

        PanCakeWithEgg panCakeWithEgg = new PanCakeWithEgg();
        System.out.println(panCakeWithEgg.getMsg() + ", 总价" + panCakeWithEgg.getPrice());

        PanCakeWithEggAndSauage panCakeWithEggAndSauage = new PanCakeWithEggAndSauage();
        System.out.println(panCakeWithEggAndSauage.getMsg() + ", 总价" + panCakeWithEggAndSauage.getPrice());
    }
}

输出:
煎饼, 总价5
煎饼,加1个鸡蛋, 总价6
煎饼,加1个鸡蛋,再+1根香肠, 总价8
```

这样的方式无法进行定制化的满足顾客要求，我想加3个鸡蛋2个烤肠，难道每次都要重写吗？使用装饰者可以解决此类问题：

```java
// 饼抽象类
public abstract class PanCake {

    protected abstract String getMsg();

    protected abstract int getPrice();

    protected abstract void doSomething();

}

// 基础煎饼，什么都不加；继承饼抽象类
public class BasePanCake extends PanCake {
    @Override
    protected String getMsg() {
        return "煎饼";
    }

    @Override
    protected int getPrice() {
        return 5;
    }

    @Override
    protected void doSomething() {

    }
}

// 煎饼装饰器类;继承饼抽象类
public class PanCakeDecorator extends PanCake{

    private  PanCake panCake;

    public PanCakeDecorator(PanCake panCake) {
        this.panCake = panCake;
    }

    @Override
    protected String getMsg() {
        return this.panCake.getMsg();
    }

    @Override
    protected int getPrice() {
        return this.panCake.getPrice();
    }

    @Override
    protected void doSomething() {

    }
}

// 装饰器：加一个鸡蛋；继承煎饼装饰器类
public class EggPanCakeDecorator extends PanCakeDecorator {
    public EggPanCakeDecorator(PanCake panCake) {
        super(panCake);
    }

    protected String getMsg() {
        return super.getMsg() + ",加1个鸡蛋";
    }

    public int getPrice() {
        return super.getPrice() + 1;
    }
}
// 装饰器：加一个香肠；继承煎饼装饰器类
public class SauageDecorator extends PanCakeDecorator {
    public SauageDecorator(PanCake panCake) {
        super(panCake);
    }

    protected String getMsg(){ return super.getMsg() + ",加1根香肠";}

    public int getPrice(){ return super.getPrice() + 2;}
}

// 客户端调用
public class Client {
    public static void main(String[] args) {
        PanCake panCake;
        panCake = new BasePanCake();
        // 加一个鸡蛋
        panCake = new EggPanCakeDecorator(panCake);
        // 再加一个鸡蛋
        panCake = new EggPanCakeDecorator(panCake);
        // 加一根香肠
        panCake = new SauageDecorator(panCake);
        System.out.println(panCake.getMsg() + "，总价" + panCake.getPrice());
    }
}

输出：
煎饼,加1个鸡蛋,加1个鸡蛋,加1根香肠，总价9
```

### 优缺点

**装饰器模式和代理模式对比**

1. 装饰器模式是一种特殊的代理模式
2. 装饰器模式强调自身的功能扩展，透明扩展，可动态定制的扩展
3. 代理模式强调代理过程的控制

**装饰器模式和适配器模式对比**

1. 定义上：装饰器和被装饰器都实现同一个接口；适配器和被适配器没有必然关系，通常会采用继承
2. 功能上：装饰器注重覆盖、扩展功能；适配器注重兼容、转换
3. 设计上：装饰器一般前置；适配器一般后置

**优点**

1. 装饰器是继承的有力补充，比继承灵活，不改变原有对象的情况下动态地给一个对象扩展功能，即插即用
2. 通过使用不同装饰器类以及这些装饰类的排列组合，可实现不同效果
3. 装饰器完全遵守开闭原则

**缺点**

1. 会出现更多的代码，更多的类，增加程序复杂性
2. 动态装饰时，多层装饰时会更复杂

## 享元模式

> 享元模式又称为轻量级模式，是对象池的一种实现。类似于线程池，线程池可以避免不停的创建和销毁多个对象，消耗性能。提供了减少对象数量从而改善应用所需的对象结构的方式。
>
> 宗旨：共享细粒度对象，将多个对同一对象的访问集中起来。
>
> 属于结构性模式。

享元模式把一个对象的状态分为内部状态和外部状态，内部状态是不变的，外部状态是变化的；然后通过共享不变的部分，达到减少对象数量并节约内存的目的。**享元本质是缓存共享对象，降低内存消耗**。

看一下享元模式的通用UML图：

![](.\pics\享元通用类图.png)

抽象享元角色(IFlyweight)：享元对象抽象基类或者接口，同时定义出对象的外部状态和内部状态的接口或实现

具体享元角色(ConcreteFlyweight)：实现抽象角色定义的业务。该角色的内部状态处理应该与环境无关，不能出现会有一个操作改变内部状态，同时修改了外部状态。

享元工厂(FlyweightFactory)：负责分享管理享元对象池和创建享元对象。

### 适用场景

​		享元模式其实就是工厂模式的一个改进机制，享元模式同样要求创建一个或一组功能，并且就是通过工厂方式生成对象的，只不过享元模式为工厂方法增加了缓存这一功能。主要应用场景有：

1. 常常用于系统低层的开发，以便解决系统的性能问题
2. 系统有大量相似对象，需要缓冲池的场景

### 享元应用

模拟下过年春节各大软件APP进行抢票，一般去12306官网扫描有没有余票信息，一旦有票出来就会放在票池里面，给分发给用户。通过票池缓存对象，这样在某个瞬间有大量请求打进服务器的时候，系统会直接从缓存中获取该票对象，并复用提供给所有查询请求，而不是每个请求都创建一个对象，增加内存压力。

```java
// 享元对象，票的接口
public interface ITicket {
    // 查看票的信息
    void showInfo(String bunk);
}

// 火车票
public class TrainTicket implements ITicket {
    private String fromAddr;
    private String toAddr;
    private double price;

    public TrainTicket(String fromAdd, String toAdd) {
        this.fromAddr = fromAdd;
        this.toAddr = toAdd;
    }

    @Override
    public void showInfo(String bunk) {
        // 票价随机生成
        this.price = new Random().nextInt(500);
        System.out.printf("%s->%s：%s价格：%s 元%n", this.fromAddr, this.toAddr, bunk, this.price);
    }
}

// 火车票工厂类
public class TicketFactory {

    private static final Map<String, ITicket> ticketPool = new ConcurrentHashMap<String, ITicket>();

    public static ITicket queryTicket(String from, String to) {
        String key = from + "->" + to;
        if (TicketFactory.ticketPool.containsKey(key)) {
            System.out.println("使用缓存：" + key);
            return TicketFactory.ticketPool.get(key);
        }
        System.out.println("首次查询，创建对象: " + key);
        ITicket ticket = new TrainTicket(from, to);
        TicketFactory.ticketPool.put(key, ticket);
        return ticket;
    }
}

// 客户端调用
public class Client {
    public static void main(String[] args) {
        ITicket ticket = TicketFactory.queryTicket("北京西", "合肥");
        ticket.showInfo("硬座");
        ticket = TicketFactory.queryTicket("北京西", "合肥");
        ticket.showInfo("软座");
        ticket = TicketFactory.queryTicket("北京西", "合肥");
        ticket.showInfo("硬卧");
    }
}
```

这样看来享元模式和注册式单例一样，但重点是不同的。享元模式使用工厂不止让对象只创建一次，根据业务工厂Map中的key可以传不同的值。**享元关注的不是对象的创建过程，而是对象的重复利用。**



再看一下JDK内部享元模式应用

```java
public class IntegerTest {
    public static void main(String[] args) {

        Integer a = Integer.valueOf(100);
        Integer b = 100;

        Integer c = Integer.valueOf(1000);
        Integer d = 1000;

        System.out.println("a==b:" + (a == b)); // true
        System.out.println("c==d:" + (c == d)); // false
    }

}
```

当常量是100的时候，两种初始化相等；当常量是1000时，两种初始化不等。这就利用了享元模式，JDK判断在-128-127的数经常使用，于是使用享元模式进行了缓存。也就是说在[-128,127]之间的值使用Integer.valueOf()方法，实际取的是缓存中的值。Long等其他基础类型也同样做了这种优化

![](.\pics\享元模式-IntegerValueOf.png)

**内部状态和外部状态**

内部状态是不会随环境改变而改变的，如连接对象中的用户名、密码、URL等信息；外部状态是对象依赖的标记，会随环境改变、不可共享状态如连接回收利用时，需要标记为可用状态，这些为外部状态。

### 优缺点

**优点**

1. 减少对象的创建，降低内存中对象的数量，降低系统的内存，提高效率
2. 减少内存之外的其他资源占用

**缺点**

1. 关注内、外部状态、关注线程安全问题
2. 逻辑复杂化

## 组合模式

> 组合模式也称为整体-部分模式，它的宗旨使通过将单个对象(叶子节点)和组合对象(树枝节点)**用相同的接口**进行表示。
>
> 作用：使客户端对单个对象和组合对象保持一致的方式处理
>
> 属于结构性模式

组合关系和聚合关系的区别：**组合是具有相同的生命周期**，公司和部门的关系是组合关系，公司有很多部门，但是每个部门都只属于公司。**聚合具有不同的生命周期**，如老师和同学关系，一个老师有很多同学，而一个同学又属于很多老师。

组合模式包含三个角色：

1. 抽象根节点：定义系统各层次对象的共有方法和属性，可以预定义一些默认行为和属性
2. 树枝节点：定义树枝节点的行为，存储子节点，组合树枝节点和叶子节点形成一个树形结构
3. 叶子节点：叶子节点对象，其下再无分支，是系统层次遍历的最小单位。

### 适用场景

当子系统与其内各个对象层次呈现树形结构时，可以适用组合模式让子系统内各个对象层次的行为操作具备一致性。客户端适用该子系统内任意一个层次对象时，无须进行区分，直接适用通用操作即可，为客户端的适用带来了便捷。

主要有以下应用场景：

1. 希望客户端可以忽略组合对象与单个对象的差异时；
2. 对象层次具备整体和部分，呈属性结构(如树形菜单，操作系统目录结构，公司组织架构等)

### 组合应用

以系统目录为例，目录下有文件夹和文件，文件是叶子节点，文件夹是树枝节点。

#### 透明组合模式

透明组合模式时把所有公共方法都定义在抽象根节点上，这样做的好处时无需辨别叶子节点和树枝节点。

```java
// 文件夹基类，透明模式下把所有公共方法都定义在抽象根节点上
// 公共默认方法是抛出异常处理，需要使用的树枝节点或者叶子节点可以重写方法
public abstract class Directory {

    protected String name;

    public Directory(String name) {
        this.name = name;
    }

    public abstract void show();

    public boolean add(Directory dir){
        throw new UnsupportedOperationException("不支持添加操作");
    }

    public boolean remove(Directory dir) {
        throw new UnsupportedOperationException("不支持删除操作");
    }

    public Directory get(int index) {
        throw new UnsupportedOperationException("不支持获取操作");
    }

    public void list(){
        throw new UnsupportedOperationException("不支持遍历操作");
    }
}

// 文件夹节点
public class Folder extends Directory {
    private List<Directory> dirs;

    private Integer level;

    public Folder(String name, Integer level) {
        super(name);
        this.level = level;
        this.dirs = new ArrayList<>();
    }

    @Override
    public void show() {
        System.out.println(this.name);
        for (Directory dir : dirs) {
            // 控制显示格式
            if (this.level != null) {
                for (int i = 0; i < this.level; i++) {
                    // 根据level控制空格输出
                    System.out.print("    ");
                }
                for (int i = 0; i < this.level; i++) {
                    if(i==0){
                        System.out.print("");
                    }
                    System.out.print("-");
                }
            }
            dir.show();
        }
    }

    @Override
    public boolean add(Directory dir) {
        return this.dirs.add(dir);
    }

    @Override
    public boolean remove(Directory dir) {
        return this.dirs.remove(dir);
    }

    @Override
    public Directory get(int index) {
        return this.dirs.get(index);
    }

    @Override
    public void list() {
        for (Directory dir : this.dirs) {
            System.out.println(dir.name);
        }
    }
}

// 文件叶子节点
public class File extends Directory {
    public File(String name) {
        super(name);
    }

    @Override
    public void show() {
        System.out.println(this.name);
    }
}

// 客户端调用
public class Client {
    public static void main(String[] args) {

        System.out.println("============透明组合模式===========");

        File qq = new File("QQ.exe");
        File wx = new File("微信.exe");

        Folder office = new Folder("办公软件", 2);

        File word = new File("Word.exe");
        File ppt = new File("PowerPoint.exe");
        File excel = new File("Excel.exe");

        office.add(word);
        office.add(ppt);
        office.add(excel);

        Folder wps = new Folder("金山软件", 3);
        wps.add(new File("WPS.exe"));
        office.add(wps);

        Folder root = new Folder("根目录", 1);
        root.add(qq);
        root.add(wx);
        root.add(office);

        System.out.println("----------show()方法效果-----------");
        root.show();

        System.out.println("----------list()方法效果-----------");
        root.list();
    }
}
//============透明组合模式===========
//        ----------show()方法效果-----------
//        根目录
//        -QQ.exe
//        -微信.exe
//        -办公软件
//              --Word.exe
//              --PowerPoint.exe
//              --Excel.exe
//              --金山软件
//                  ---WPS.exe
//        ----------list()方法效果-----------
//        QQ.exe
//        微信.exe
//        办公软件
```

透明组合模式使得叶子节点file和树节点folder具备完全一致的接口；缺点是叶子节点leaf会继承得到一些它所不需要(管理子类操作)的方法，这与设计模式 接口隔离原则相违背。

#### 安全组合模式

安全模式之规定系统各个层次的最基础的行为，把组合(树节点)本身的方法(对子类的操作，增删改等)放到自身当中：相较于透明组合模式，只变更了基类中的方法。

```java
public abstract class Directory {
    protected String name;

    public Directory(String name) {
        this.name = name;
    }

    public abstract void show();

}
```

安全组合模式对接口定义职责清晰，符合设计模式单一职责原则和接口隔离原则；缺点是客户需要区分树枝节点和叶子节点，这样才能正确处理各个层次的操作，客户端无法依赖抽象，违背了设计模式依赖倒置原则。



在HashMap中也用到了组合模式

![](.\pics\组合模式HashMap.png)

putAll方法传入的是Map对象，Map就是一个抽象构建，只支持键值对的存储格式；HashMap是其中一种实现。

同样的还是ArrayList的addAll方法，添加的是父类的Collection

![](.\pics\组合模式ArrayList.png)

**不管是组合对象还是被组合对象都应该有统一的接口实现或抽象父类。**

### 优缺点

当系统绝大多数行为具备相同的公共行为时，可以采用透明组合模式，节省开发，代价时为少数节点引入不需要的方法；如果系统各个层次差异性较大，采用安全组合模式。

**优点**

1. 清楚定义分层次的复杂结构，表示对象的全部或部分层次
2. 让客户端忽略了层次的差异，方便对整个层次结构进行控制
3. 简化客户端调用代码
4. 符合开闭原则

**缺点**

1. 限制类型时会比较复杂
2. 使设计更加抽象

## 适配器模式

> 适配器又叫变压器模式，它的功能是将一个类的接口变成客户端所期望的另一种接口，从而使原本因接口不匹配而导致无法在一起工作的两个类能够一起工作。
>
> 属于结构性设计模式

适配器模式一般包含三种角色：

目标角色(Target)：也就是期望的接口；

源角色(Adaptee)：存在于系统中，内容满足客户需求，但接口不匹配的接口实例；

适配器：将源角色(Adaptee)转化为目标角色(Target)的类实例

![](.\pics\适配器通用类.png)



### 适用场景

适配器各角色之间关系：假设客户端需要访问的是target接口，但target的实例中没有符合要求的，而Adaptee实例符合需求，但是客户端无法直接使用Adaptee(接口不兼容)；因此，需要一个适配器Adapter来进行中转，让Adaptee能转化为Target接口形式。

1. 已经存在的类，它的方法和需求不匹配(方法结果相同或相似)的情况
2. 适配器模式不是软件设计阶段考虑的设计模式，而是随着软件维护，由于不同产品、不同厂家造成功能类似而接口不同情况下的解决方案。

### 适配应用

适配器有三种形式：类适配器、对象适配器以及接口设配器

当前有个220V输出的电源Adaptee，我的手机IPhone13 Pro Max 1TB(远峰蓝)支持5V标准电压输入Target，此时需要一个转换器Adapter。

#### 类适配器

类适配器通过继承来实现适配器的功能。具体做法：Adapter是心啊Target接口，并且继承Adaptee，这样Adapter就具备Target和Adaptee特性，可以将两者进行转化。

```java
public class Adaptee {

   public int output220V(){
       int src = 220;
       System.out.println("电压=" + src);
       return src;
   }
}

public interface Target {
    int outPut5V();
}

public class Adapter extends Adaptee implements Target {

    @Override
    public int outPut5V() {
        int srcV = output220V();
        return srcV / 44;
    }
}

public class Client {

    public static void main(String[] args) {
        Adapter adapter = new Adapter();
        int res = adapter.outPut5V();
        System.out.println("类适配器输出电压：" + res);
    }
}
//电压=220
//类适配器输出电压：5
```

**优点**

1. 适配器继承了被适配的类Adaptee，使得适配器可以重写被适配的类方法，提供了适配器的灵活性

**缺点**

1. Java是单继承，适配器继承了被适配的类，所以适配器只能是接口
2. 被适配的类方法在适配器中都会暴露出来，增加了使用成本

#### 对象适配器

对象适配器的原理就是通过组合来实现适配器功能。让Adapter实现Target接口，然后内部持有Adaptee实例，然后再Target接口规定的方法内转换Adaptee。

代码只需要更改适配器(Adapter)实现，从**继承关系变成了聚合关系**，其他与类适配器一致：

```java
public class Adapter implements Target {

    private Adaptee adaptee;

    public Adapter(Adaptee adaptee) {
        this.adaptee = adaptee;
    }

    @Override
    public int outPut5V() {
        int srcV = adaptee.output220V();
        return srcV / 44;
    }
}
//电压=220
//对象适配器输出电压：5
```

**优点**

- 利用合成复用原则, 使用聚合代替了继承
- 解决了类适配器必须继承被适配的类
- 成本低, 更灵活

**缺点**

- 要全部实现接口里的方法(如果接口里还有一个转为22V的方法, 也要实现)

#### 接口适配器

在对象适配器中解决了继承解耦的问题，那么能不能从接口这边解耦？

当接口方法过多的时候，又不需要全部实现接口提供的方法，可以先设计一个基础抽象类实现接口，为每个方法提供一个默认实现方法，然后实际适配器继承该基础抽象类并选择性的覆盖父类的某些方法来实现需求。

```java
public class Adaptee {

   public int output220V(){
       int src = 220;
       System.out.println("电压=" + src);
       return src;
   }
}

public interface Target {

    int outPut5V();

    int outPut22V();// 不需要的方法

    String hello();// 不需要的方法
}

public class TargetAdapter implements Target {
    @Override
    public int outPut5V() {
        return 0;
    }

    @Override
    public int outPut22V() {
        return 0;
    }

    @Override
    public String hello() {
        return null;
    }
}

public class Adapter extends TargetAdapter {

    private Adaptee adaptee;

    public Adapter(Adaptee adaptee) {
        this.adaptee = adaptee;
    }

    @Override
    public int outPut5V() {
        int srcV = adaptee.output220V();
        return srcV / 44;
    }
}

public class Client {

    public static void main(String[] args) {
        Adapter adapter = new Adapter(new Adaptee());
        int res = adapter.outPut5V();
        System.out.println("接口适配器输出电压：" + res);
    }
}
//电压=220
//接口适配器输出电压：5
```

**优点**

- 可以选择性的实现接口提供的方法
- 更灵活了

### 优缺点

**优点**

1. 能提高类的透明性和复用，现有的类复用但不需要改变
2. 目标类和适配器类解耦，提高程序的扩展性
3. 在很多业务场景中符合开闭原则

**缺点**

1. 适配器编写过程需要全面考虑，可能会增加系统的复杂性
2. 增加代码阅读难度，降低代码可读性，过多使用适配器会使系统代码变得凌乱

适配器不应该是在设计之初考虑的，不同于装饰器模式的前置考虑，它属于后置考虑；装饰器和被装饰器通过实现同一个接口，来达到覆盖、扩展的目的；适配器和被适配器没有必然的联系，通常是采用继承或代理的形式进行包装，来达到兼容、转换的目的。