---
typora-root-url: pics
---

# 设计模式



[toc]
## 六大设计原则
> 设计模式是一套理论，是软件界的先辈们总结出的一套可以反复使用的经验。它可以提高代码的可重用性，增强系统的可维护性，以及解决一系列的复杂问题。

在学习设计模式之前，先要明白六大设计原则，设计模式是在六大设计原则上的实践。

### 开闭原则

- 开闭原则定义：软件实体应该对扩展开放，对修改关闭。
- 开闭原则的好处：
  - 可以减少测试的工作量
  - 可以提高复用性
  - 可以提高可维护性
  - 面向对象开发的要求

### 单一职责原则

- 单一职责的定义是：应该有且仅有一个原因引起类的变更
- 单一职责的好处：
    - 类的复杂度降低，实现什么职责都有清晰明确的定义
    - 可读性提高
    - 可维护性提高
    - 变更引起风险降低
- 在写代码的时候，尽量做到单一职责。但职责的划分很难确认，要根据环境、项目、资源等而定，但还是尽量做到类的设计只有一个原因引起变化。

### 接口隔离原则

- 接口隔离原则的定义：
  - 客户端不应该依赖它不需要的接口
  - 类间的依赖关系应该建立在最小的接口上

> 总结一句话是：建立单一接口，不要建立臃肿庞大的接口。再通俗点就是：接口尽量细化，同时接口的方法尽量少。

```html
接口隔离原则和单一职责原则是相同的吗？

是不同的。单一职责注重的是职责，要求职责单一，属于业务逻辑上的划分。接口隔离原则要求接口的方法尽量少，当二者发生冲突时，首先满足单一职责原则。
```

- 接口隔离原则也就是要做到高内聚。
- 接口的设计粒度越小，系统越灵活，但是灵活的同时也带来了结构的复杂化，开发难度增加，可维护性降低。需要深入了解业务逻辑，根据经验和常识决定接口的粒度大小，太小增加开发工作量，太大灵活度降低。

### 迪米特法则

- 迪米特法则：一个对象应该对其他对象有最少的了解。
- 迪米特法则的核心观念就是类间的解耦，弱耦合，类的复用率才可以提供。如果一个方法放在本类中，既不增加类间关系，也不对本类产生负面影响，那就放置在本类中。

### 里氏替换原则

- 里式替换原则的定义：只要父类能出现的地方子类就可以出现，而且替代为子类也不会产生任何错误和异常，使用者可能根本不需要知道谁是父类谁是子类。但是，反过来就不行了，有子类出现的地方，父类未必能适应。
- 里式替换原则的目的就是增强程序的健壮性，版本升级时也可以保持非常好的兼容性。即使增加子类，原有的子类还可以继续运行。

### 依赖倒置原则
- 依赖倒置的表现：
    1. 模块间的依赖通过抽象发生，实现类之间不发生直接的依赖关系，其依赖关系是通过接口或抽象类产生的。
    2. 接口或抽象类不依赖于实现类。
    3. 实现类依赖接口或抽象类。

> 更加精简的定位是“面向接口编程”

- 采用依赖倒置原则可以减少类间的耦合性，提高系统的稳定性，降低并行开发引起的风险，提高代码的可读性和可维护性。
- 依赖倒置原则的本质就是通过抽象使各个类或模块的实现彼此独立，不互相影响，实现模块间的松耦合。核心就是“面向接口编程”
> 为什么叫“倒置”，首先说“正置”是什么意思，依赖正置就是类间的依赖是实实在在的实现类间的依赖，也就是面向实现编程，也是正常生活的思维，要开车就依赖车，要用电脑就依赖电脑，而编写程序需要对现实世界的事物进行抽象，抽象的结果就是有了抽象类和接口，然后我们根据系统设计的需要产生了抽象间的依赖，代替了人们传统思维中的事物间的依赖，“倒置”就是从这里产生的。

## 简单工厂模式

> 简单工厂模式是指由一个工厂对象决定创建出哪一种产品类的实例，属于创建者模式，但它不属于23种设计模式。

最直观的思维方式是需要什么，创建什么。例如我需要一门课程，那么就创建一门课程来：

```java
public class MathCourse {

    public void  create(){
        System.out.println("MathCourse创建数学课程");
    }
}

public class Test {
    public static void main(String[] args) {
        // 直接创建
        MathCourse mathCourse = new MathCourse();
        mathCourse.create();
    }
}

输出：
MathCourse创建数学课程
```

但是如果用户同时需要英语课、语文课、政治课...等，那么则需要创建多个课程。根据六大设计原则之一的依赖倒置原则：面向接口编程。可以新建一个学科接口类，实际学科去实现这个接口类：

```java
public interface Course {

    /**
     * 创建课程
     */
    void create();
}

public class MathCourseImpl implements Course {
    @Override
    public void create() {
        System.out.println("MathCourseImpl创建了数学课程");
    }
}

public class EnglishCourseImpl implements Course {
    @Override
    public void create() {
        System.out.println("EnglishCourseIml创建了英语课程");
    }
}

public class Test {
    public static void main(String[] args) {
       // 面向接口创建
        Course course = new MathCourseImpl();
        course.create();
        Course course1 = new EnglishCourseImpl();
        course1.create();
    }
}

输出：
MathCourseImpl创建了数学课程
EnglishCourseImpl创建了英语课程
```

面向接口编程提高了代码的可读性和可维护性，但是目前所有课程还是用户自己new出来的，如果创建过程比较麻烦，这样用户还需要了解每种课程(然而**用户并不关心课程如何创建的，只需要使用**)。这里可以提供一种工厂类，使用工厂类只要传入用户想要的东西，就可以返回结果，而不需要用户关注具体的创建过程，实现类之间的解耦。

```java
public class CourseFactory {
    /**
     * 通过if判断创建
     */
    public Course createByIf(String name) {
        if ("math".equals(name)) {
            return new MathCourseImpl();
        } else if ("english".equals(name)) {
            return new EnglishCourseImpl();
        } else {
            return null;
        }
    }
}

public class Test {
    public static void main(String[] args) {
        // 简单工厂创建
        // 通过if判断创建
        CourseFactory courseFactory = new CourseFactory();
        Course mathCourseIf = courseFactory.createByIf("math");
        System.out.println("=======if=========");
        mathCourseIf.create();
        System.out.println("=======if=========");
}

输出：
=======if=========
MathCourseImpl创建了数学课程
=======if=========
```

上面代码提供了工厂类，只需要传入相应的学科名就可以创建对应的课程类。如果课程很多，那么将会有很多的if、else判断，可以对工厂使用反射的方法进行优化。

```java
public class CourseFactory {
    /**
     * 通过反射创建
     */
    public Course createByReflect(String name) {
        try {
            if (!(null == name || "".equals(name))) {
                return (Course) Class.forName(name).newInstance();
            }
        } catch (Exception e) {
            e.printStackTrace();
            System.out.println("创建" + name + "实例失败！");
        }
        return null;
    }
}

public class Test {
    public static void main(String[] args) {
        // 通过反射创建
        System.out.println("=======reflect=========");
   courseFactory.createByReflect("cn.eamon.study.gp01_simple_factory.EnglishCourseImpl").create();
        System.out.println("=======reflect=========");
    }
}

输出：
=======reflect=========
EnglishCourse创建了英语课程
=======reflect=========
```

通过反射创建实例，能很好优化代码，但是在实际使用的时候对传参要求很高，需要输入类的全路径名称。再结合泛型可以继续优化代码：

```java
public class CourseFactory {
    /**
     * 通过反射+泛型指定创建类型课程
     */
    public Course createByReflectExtends(Class<? extends Course> clazz){
        try{
            if(null!=clazz){
                return clazz.newInstance();
            }
        }catch (Exception e){
            e.printStackTrace();
            System.out.println("创建" + clazz + "实例失败！");
        }
        return null;
    }
}

public class Test {
    public static void main(String[] args) {
        // 通过反射+泛型指定创建课程
        System.out.println("=======reflect+extends=========");
        courseFactory.createByReflectExtends(MathCourseImpl.class).create();
        System.out.println("=======reflect+extends=========");
    }
}

输出：
=======reflect+extends=========
MathCourseImpl创建了数学课程
=======reflect+extends=========
```

通过泛型传递，这样开发工具在你传参的时候，还能够智能化提醒，进一步增加使用的便捷性。



看看Calendar类是如何实例化的Calendar.getInstance()：

```java
public static Calendar getInstance()
    {
    	// 工厂创建Calendar实例
        return createCalendar(TimeZone.getDefault(), Locale.getDefault(Locale.Category.FORMAT));
    }

private static Calendar createCalendar(TimeZone zone,
                                           Locale aLocale)
    {
        CalendarProvider provider =
            // 工厂创建Calendar实例
            LocaleProviderAdapter.getAdapter(CalendarProvider.class, aLocale) 
                                 .getCalendarProvider();
        if (provider != null) {
            try {
                return provider.getInstance(zone, aLocale);
            } catch (IllegalArgumentException iae) {
                // fall back to the default instantiation
            }
        }
    ···
}

// 使用泛型指定入参类型
 public static LocaleProviderAdapter getAdapter(Class<? extends LocaleServiceProvider> var0, Locale var1) {...}
```



**简单工厂的优点**：只需要传入一个正确的参数，就可以获取你所需要的对象，无须知道其创建的细节。

**简单工厂的缺点**：工厂类的职责过重，增加新的场景时需要修改工厂类的判断逻辑，违背开闭原则；不易于扩展复杂的产品结构。

**适用场景**：工厂类负责创建的对象较少。

## 工厂方法模式

> 工厂方法模式是指定义一个创建对象的接口，但让实现这个接口的类来决定实例化哪个类，工厂方法让类的实例化推迟到子类中进行。

在简单工厂中提到**简单工厂的缺点是职责过重，既不符合单一原则也不符合开闭原则**，如何工厂方法模式在一定程度上可以解决简单工厂的缺点。

同样是面向课程接口实现具体的课程类：

```java
public interface ICourse {

    /**
     * 创建课程
     */
    void create();
}

public class EnglishCourseImpl implements ICourse {
    @Override
    public void create() {
        System.out.println("EnglishCourseImpl创建了英语课程");
    }
}

public class MathCourseImpl implements ICourse {
    @Override
    public void create() {
        System.out.println("MathCourseImpl创建了数学课程");
    }
}
```

与简单工厂的区别，进一步将工厂同课程面向接口编程：

```java
public interface ICourseFactory {
    /**
     * 创建课程工厂
     */
    ICourse create();
}

public class EnglishCourseFactory implements ICourseFactory {
    @Override
    public ICourse create() {
        return new EnglishCourseImpl();
    }
}

public class MathCourseFactory implements ICourseFactory {
    @Override
    public ICourse create() {
        return new MathCourseImpl();
    }
}
```

这样在用户使用的时候便可以实例化不同的工厂类，创建具体的课程：

```java
public class Test {
    public static void main(String[] args) {
        // 数学课程
        ICourseFactory factory = new MathCourseFactory();
        ICourse course = factory.create();
        course.create();
        // 英语课程
        factory = new EnglishCourseFactory();
        factory.create().create();
    }
}

输出：
MathCourseImpl创建了数学课程
EnglishCourseImpl创建了英语课程
```

![](.\pics\工模式类图.png)

相比较于简单工厂，它用户更好的扩展性；当出现新的应用场景时，只需要新增一个接口的实现类即可，不需要修改原来的代码。符合单一职责、接口隔离以及依赖倒置原则。



在slf4j中工厂方法模式的应用

![](.\pics\logger类图.png)



**工厂方法模式的优点**

- 有良好的封装性，代码结构清晰：创建产品对象，不需要知道创建过程，只要知道类名就可以，降低模块间的耦合。
- 工厂方法模式符合开闭原则，扩展性非常优秀：想要增加产品类，只要适当修改具体的工厂类或者扩展一个工厂类，就可以“拥抱变化”。

**工厂方法模式的缺点**

- 类的个数容易过多，增加了代码结构的复杂度
- 增加了系统的抽象性和理解难度

**适用场景**

- 创建对象需要大量重复的代码
- 客户端不依赖产品类如何被创建、实现等细节

## 抽象工厂模式

> 抽象工厂模式是指提供一个创建一系列相关或相互依赖对象的接口，无须指定他们具体的类。

在工厂方法模式提到其缺点是**类的个数过多，增加了代码结构的复杂度**，抽象工厂模式可以一定程度上解决工厂方法模式的缺点。抽象工厂模式根据业务属性将接口粗化，将相关的接口方法定义在同一个接口类中。



在学习课程的时候，是会做笔记和回答老师的提问。也就是说每个课程都会做笔记方法和回答问题的方法，在创建课程的时候一并实现做笔记方法和回答问题方法。先定义好相关的接口和类：

课程接口和实现类

```java
public interface ICourse {

    /**
     * 创建课程
     */
    void create();
}

public class EnglishCourseImpl implements ICourse {
    @Override
    public void create() {
        System.out.println("EnglishCourse创建了英语课程");
    }
}

public class MathCourseImpl implements ICourse {
    @Override
    public void create() {
        System.out.println("MathCourseImpl创建了数学课程");
    }
}

```

回答问题接口和实现类

```java
public interface IAnswer {
    /**
     * 回答问题
     */
    void speak();
}

public class EnglishAnswerImpl implements IAnswer {
    @Override
    public void speak() {
        System.out.println("回答英语问题");
    }
}

public class MathAnswerImpl implements IAnswer {
    @Override
    public void speak() {
        System.out.println("回答数学问题");
    }
}
```

笔记接口和实现类

```java
public interface INote {
    /**
     * 做笔记
     */
    void edit();
}

public class EnglishNoteImpl implements INote {
    @Override
    public void edit() {
        System.out.println("写英语笔记");
    }
}

public class MathNoteImpl implements INote {
    @Override
    public void edit() {
        System.out.println("写数学笔记");
    }
}
```

接着定义课程抽象工厂

```java
public abstract class CourseFactory {
    public void init(){
        System.out.println("初始化参数");
    }

    /**
     * 创建笔记
     */
    public abstract INote createNote();

    /**
     * 回答问题
     */
    public abstract IAnswer createAnswer();
}


public class EnglishCourseFactory extends CourseFactory {
    @Override
    public INote createNote() {
        return new EnglishNoteImpl();
    }

    @Override
    public IAnswer createAnswer() {
        return new EnglishAnswerImpl();
    }
}

public class MathCourseFactory extends CourseFactory {
    @Override
    public INote createNote() {
        super.init();
        return new MathNoteImpl();
    }

    @Override
    public IAnswer createAnswer() {
        return new MathAnswerImpl();
    }
}
```

客户端使用：

```java
public class Test {

    public static void main(String[] args) {
        CourseFactory factory = new MathCourseFactory();
        factory.createNote().edit();
        factory.createAnswer().speak();
    }
}
输出：
初始化参数
写数学笔记
回答数学问题
```

**抽象工厂模式的优点**

- 具体产品在应用层代码隔离，无须关系创建细节
- 将一个系列的产品族统一到一起创建

**抽象工厂模式的优点**

- 规定了所有可能被创建的产品集合，产品族扩展新的产品困难，需要修改抽象工厂的接口
- 增加了系统的抽象性和理解难度

**适用范围**

- 强调一系列相关的产品对象一起使用，创建对象需要大量重复代码
- 客户端不依赖于产品类如何被创建、实现等细节



**简单工厂、工厂方法、抽象工厂三者的理解**

> 在一些简单场景，且未来可能不发生变化或变化较少的情况下使用简单工厂；
>
> 较复杂的情况下使用工厂方法；
>
> 抽象工厂需要结合业务理解和发展来考虑的，在设计和开发期间比较难考虑产品的未来发展，通常使用工厂方法模式即可；面对已有的并且有大量重复代码可以使用抽象工厂模式进行代码优化。

## 单例模式

> 单例模式能够确保某一个类只有一个实例，并提供一个全局访问点。单例隐藏了所有的构造方法，属于创建型模式。

### 饿汉式单例

一个简单的饿汉式单例，在类初始化的时候创建。

```java
public class HungrySingleton {

    private static final HungrySingleton hungrySingleton = new HungrySingleton();

    public HungrySingleton() {
    }

    public static HungrySingleton getInstance() {
        return hungrySingleton;
    }
}
```

优点：执行效率高，性能高，没有任何的锁

缺点：某些情况下，会造成浪费内存

### 懒汉式单例 

一个简单的饿汉式单例，需要的时候才创建实例。

```java
public class LazySimpleSingleton {

    private static LazySimpleSingleton instance;

    private LazySimpleSingleton() {
    }

    public static LazySimpleSingleton getInstance() {
        if (instance == null) {
            instance = new LazySimpleSingleton();
        }
        return instance;
    }
}
```

优点：节省了内存

缺点：线程不安全



线程不安全是如何体现的，示例:

```java
// 实现一个线程类
public class ExecutorThread implements Runnable {
    @Override
    public void run() {
        LazySimpleSingleton instance = LazySimpleSingleton.getInstance();
        System.out.println(Thread.currentThread().getName() + ":" + instance);
    }
}

// 测试方法
public class LazySimpleSingletonTest {

    public static void main(String[] args) {
        Thread t1 = new Thread(new ExecutorThread());
        Thread t2 = new Thread(new ExecutorThread());
        t1.start();
        t2.start();
        System.out.println("执行结束");
    }
}
```

出现两种运行结果：

![](F:\Code\JavaTrip\course08-desigin-pattern\src\main\java\note\pics\线执行结果相同.png)



![](/线执行结果不同.png)

- 出现同一个实例
  - 正常顺序执行
  - 后者覆盖前者

- 出现不同的实例
  - 同时进入条件，按顺序返回

原因是创建实例时**`instance = new LazySimpleSingleton();`**不是一个原子类操作，存在线程风险。

那么我们只要给创建实例的方法加一个synchronized关键字就可以解决线程风险的问题：

```java
public class LazySimpleSingleton {
	
    private synchronized static LazySimpleSingleton instance;

    private LazySimpleSingleton() {
    }

    public static LazySimpleSingleton getInstance() {
        if (instance == null) {
            instance = new LazySimpleSingleton();
        }
        return instance;
    }
}
```

此时饿汉式单例能够节省内存，同时线程安全；但是加锁后有明显的性能瓶颈！



### 注册式单例



### ThreadLocal单例





单例模式的优点：

1. 单例模式在内存中只有一个实例，减少了内存开支
2. 单例模式避免对资源的多重占用，例如一个写文件的动作，由于只有一个实例存在内存中，避免对同一个资源文件的同时写操作
3. 单例模式可以在系统设置全局的访问点，优化和共享资源访问

单例模式的缺点：

1. 单例模式没有接口，扩展困难。如果要扩展，必须修改代码



