# 设计模式



[toc]
## 六大设计原则
> 设计模式是一套理论，是软件界的先辈们总结出的一套可以反复使用的经验。它可以提高代码的可重用性，增强系统的可维护性，以及解决一系列的复杂问题。

在学习设计模式之前，先要明白六大设计原则，设计模式是在六大设计原则上的实践。

### 开闭原则

- 开闭原则定义：软件实体应该对扩展开放，对修改关闭。
- 开闭原则的好处：
  - 可以减少测试的工作量
  - 可以提高复用性
  - 可以提高可维护性
  - 面向对象开发的要求

### 单一职责原则

- 单一职责的定义是：应该有且仅有一个原因引起类的变更
- 单一职责的好处：
    - 类的复杂度降低，实现什么职责都有清晰明确的定义
    - 可读性提高
    - 可维护性提高
    - 变更引起风险降低
- 在写代码的时候，尽量做到单一职责。但职责的划分很难确认，要根据环境、项目、资源等而定，但还是尽量做到类的设计只有一个原因引起变化。

### 接口隔离原则

- 接口隔离原则的定义：
  - 客户端不应该依赖它不需要的接口
  - 类间的依赖关系应该建立在最小的接口上

> 总结一句话是：建立单一接口，不要建立臃肿庞大的接口。再通俗点就是：接口尽量细化，同时接口的方法尽量少。

```html
接口隔离原则和单一职责原则是相同的吗？

是不同的。单一职责注重的是职责，要求职责单一，属于业务逻辑上的划分。接口隔离原则要求接口的方法尽量少，当二者发生冲突时，首先满足单一职责原则。
```

- 接口隔离原则也就是要做到高内聚。
- 接口的设计粒度越小，系统越灵活，但是灵活的同时也带来了结构的复杂化，开发难度增加，可维护性降低。需要深入了解业务逻辑，根据经验和常识决定接口的粒度大小，太小增加开发工作量，太大灵活度降低。

### 迪米特法则

- 迪米特法则：一个对象应该对其他对象有最少的了解。
- 迪米特法则的核心观念就是类间的解耦，弱耦合，类的复用率才可以提供。如果一个方法放在本类中，既不增加类间关系，也不对本类产生负面影响，那就放置在本类中。

### 里氏替换原则

- 里式替换原则的定义：只要父类能出现的地方子类就可以出现，而且替代为子类也不会产生任何错误和异常，使用者可能根本不需要知道谁是父类谁是子类。但是，反过来就不行了，有子类出现的地方，父类未必能适应。
- 里式替换原则的目的就是增强程序的健壮性，版本升级时也可以保持非常好的兼容性。即使增加子类，原有的子类还可以继续运行。

### 依赖倒置原则
- 依赖倒置的表现：
    1. 模块间的依赖通过抽象发生，实现类之间不发生直接的依赖关系，其依赖关系是通过接口或抽象类产生的。
    2. 接口或抽象类不依赖于实现类。
    3. 实现类依赖接口或抽象类。

> 更加精简的定位是“面向接口编程”

- 采用依赖倒置原则可以减少类间的耦合性，提高系统的稳定性，降低并行开发引起的风险，提高代码的可读性和可维护性。
- 依赖倒置原则的本质就是通过抽象使各个类或模块的实现彼此独立，不互相影响，实现模块间的松耦合。核心就是“面向接口编程”
> 为什么叫“倒置”，首先说“正置”是什么意思，依赖正置就是类间的依赖是实实在在的实现类间的依赖，也就是面向实现编程，也是正常生活的思维，要开车就依赖车，要用电脑就依赖电脑，而编写程序需要对现实世界的事物进行抽象，抽象的结果就是有了抽象类和接口，然后我们根据系统设计的需要产生了抽象间的依赖，代替了人们传统思维中的事物间的依赖，“倒置”就是从这里产生的。

## 简单工厂模式

> 简单工厂模式是指由一个工厂对象决定创建出哪一种产品类的实例，属于创建者模式，但它不属于23种设计模式。

最直观的思维方式是需要什么，创建什么。例如我需要一门课程，那么就创建一门课程来：

```java
public class MathCourse {

    public void  create(){
        System.out.println("MathCourse创建数学课程");
    }
}

public class Test {
    public static void main(String[] args) {
        // 直接创建
        MathCourse mathCourse = new MathCourse();
        mathCourse.create();
    }
}

输出：
MathCourse创建数学课程
```

但是如果用户同时需要英语课、语文课、政治课...等，那么则需要创建多个课程。根据六大设计原则之一的依赖倒置原则：面向接口编程。可以新建一个学科接口类，实际学科去实现这个接口类：

```java
public interface Course {

    /**
     * 创建课程
     */
    void create();
}

public class MathCourseImpl implements Course {
    @Override
    public void create() {
        System.out.println("MathCourseImpl创建了数学课程");
    }
}

public class EnglishCourseImpl implements Course {
    @Override
    public void create() {
        System.out.println("EnglishCourseIml创建了英语课程");
    }
}

public class Test {
    public static void main(String[] args) {
       // 面向接口创建
        Course course = new MathCourseImpl();
        course.create();
        Course course1 = new EnglishCourseImpl();
        course1.create();
    }
}

输出：
MathCourseImpl创建了数学课程
EnglishCourseImpl创建了英语课程
```

面向接口编程提高了代码的可读性和可维护性，但是目前所有课程还是用户自己new出来的，如果创建过程比较麻烦，这样用户还需要了解每种课程(然而**用户并不关心课程如何创建的，只需要使用**)。这里可以提供一种工厂类，使用工厂类只要传入用户想要的东西，就可以返回结果，而不需要用户关注具体的创建过程，实现类之间的解耦。

```java
public class CourseFactory {
    /**
     * 通过if判断创建
     */
    public Course createByIf(String name) {
        if ("math".equals(name)) {
            return new MathCourseImpl();
        } else if ("english".equals(name)) {
            return new EnglishCourseImpl();
        } else {
            return null;
        }
    }
}

public class Test {
    public static void main(String[] args) {
        // 简单工厂创建
        // 通过if判断创建
        CourseFactory courseFactory = new CourseFactory();
        Course mathCourseIf = courseFactory.createByIf("math");
        System.out.println("=======if=========");
        mathCourseIf.create();
        System.out.println("=======if=========");
}

输出：
=======if=========
MathCourseImpl创建了数学课程
=======if=========
```

上面代码提供了工厂类，只需要传入相应的学科名就可以创建对应的课程类。如果课程很多，那么将会有很多的if、else判断，可以对工厂使用反射的方法进行优化。

```java
public class CourseFactory {
    /**
     * 通过反射创建
     */
    public Course createByReflect(String name) {
        try {
            if (!(null == name || "".equals(name))) {
                return (Course) Class.forName(name).newInstance();
            }
        } catch (Exception e) {
            e.printStackTrace();
            System.out.println("创建" + name + "实例失败！");
        }
        return null;
    }
}

public class Test {
    public static void main(String[] args) {
        // 通过反射创建
        System.out.println("=======reflect=========");
   courseFactory.createByReflect("cn.eamon.study.gp01_simple_factory.EnglishCourseImpl").create();
        System.out.println("=======reflect=========");
    }
}

输出：
=======reflect=========
EnglishCourse创建了英语课程
=======reflect=========
```

通过反射创建实例，能很好优化代码，但是在实际使用的时候对传参要求很高，需要输入类的全路径名称。再结合泛型可以继续优化代码：

```java
public class CourseFactory {
    /**
     * 通过反射+泛型指定创建类型课程
     */
    public Course createByReflectExtends(Class<? extends Course> clazz){
        try{
            if(null!=clazz){
                return clazz.newInstance();
            }
        }catch (Exception e){
            e.printStackTrace();
            System.out.println("创建" + clazz + "实例失败！");
        }
        return null;
    }
}

public class Test {
    public static void main(String[] args) {
        // 通过反射+泛型指定创建课程
        System.out.println("=======reflect+extends=========");
        courseFactory.createByReflectExtends(MathCourseImpl.class).create();
        System.out.println("=======reflect+extends=========");
    }
}

输出：
=======reflect+extends=========
MathCourseImpl创建了数学课程
=======reflect+extends=========
```

通过泛型传递，这样开发工具在你传参的时候，还能够智能化提醒，进一步增加使用的便捷性。



看看Calendar类是如何实例化的Calendar.getInstance()：

```java
public static Calendar getInstance()
    {
    	// 工厂创建Calendar实例
        return createCalendar(TimeZone.getDefault(), Locale.getDefault(Locale.Category.FORMAT));
    }

private static Calendar createCalendar(TimeZone zone,
                                           Locale aLocale)
    {
        CalendarProvider provider =
            // 工厂创建Calendar实例
            LocaleProviderAdapter.getAdapter(CalendarProvider.class, aLocale) 
                                 .getCalendarProvider();
        if (provider != null) {
            try {
                return provider.getInstance(zone, aLocale);
            } catch (IllegalArgumentException iae) {
                // fall back to the default instantiation
            }
        }
    ···
}

// 使用泛型指定入参类型
 public static LocaleProviderAdapter getAdapter(Class<? extends LocaleServiceProvider> var0, Locale var1) {...}
```



**简单工厂的优点**：只需要传入一个正确的参数，就可以获取你所需要的对象，无须知道其创建的细节。

**简单工厂的缺点**：工厂类的职责过重，增加新的场景时需要修改工厂类的判断逻辑，违背开闭原则；不易于扩展复杂的产品结构。

**适用场景**：工厂类负责创建的对象较少。

## 工厂方法模式

> 工厂方法模式是指定义一个创建对象的接口，但让实现这个接口的类来决定实例化哪个类，工厂方法让类的实例化推迟到子类中进行。

在简单工厂中提到**简单工厂的缺点是职责过重，既不符合单一原则也不符合开闭原则**，如何工厂方法模式在一定程度上可以解决简单工厂的缺点。

同样是面向课程接口实现具体的课程类：

```java
public interface ICourse {

    /**
     * 创建课程
     */
    void create();
}

public class EnglishCourseImpl implements ICourse {
    @Override
    public void create() {
        System.out.println("EnglishCourseImpl创建了英语课程");
    }
}

public class MathCourseImpl implements ICourse {
    @Override
    public void create() {
        System.out.println("MathCourseImpl创建了数学课程");
    }
}
```

与简单工厂的区别，进一步将工厂同课程面向接口编程：

```java
public interface ICourseFactory {
    /**
     * 创建课程工厂
     */
    ICourse create();
}

public class EnglishCourseFactory implements ICourseFactory {
    @Override
    public ICourse create() {
        return new EnglishCourseImpl();
    }
}

public class MathCourseFactory implements ICourseFactory {
    @Override
    public ICourse create() {
        return new MathCourseImpl();
    }
}
```

这样在用户使用的时候便可以实例化不同的工厂类，创建具体的课程：

```java
public class Test {
    public static void main(String[] args) {
        // 数学课程
        ICourseFactory factory = new MathCourseFactory();
        ICourse course = factory.create();
        course.create();
        // 英语课程
        factory = new EnglishCourseFactory();
        factory.create().create();
    }
}

输出：
MathCourseImpl创建了数学课程
EnglishCourseImpl创建了英语课程
```

![](.\pics\工模式类图.png)

相比较于简单工厂，它用户更好的扩展性；当出现新的应用场景时，只需要新增一个接口的实现类即可，不需要修改原来的代码。符合单一职责、接口隔离以及依赖倒置原则。



在slf4j中工厂方法模式的应用

![](.\pics\logger类图.png)



**工厂方法模式的优点**

- 有良好的封装性，代码结构清晰：创建产品对象，不需要知道创建过程，只要知道类名就可以，降低模块间的耦合。
- 工厂方法模式符合开闭原则，扩展性非常优秀：想要增加产品类，只要适当修改具体的工厂类或者扩展一个工厂类，就可以“拥抱变化”。

**工厂方法模式的缺点**

- 类的个数容易过多，增加了代码结构的复杂度
- 增加了系统的抽象性和理解难度

**适用场景**

- 创建对象需要大量重复的代码
- 客户端不依赖产品类如何被创建、实现等细节

## 抽象工厂模式

> 抽象工厂模式是指提供一个创建一系列相关或相互依赖对象的接口，无须指定他们具体的类。

在工厂方法模式提到其缺点是**类的个数过多，增加了代码结构的复杂度**，抽象工厂模式可以一定程度上解决工厂方法模式的缺点。抽象工厂模式根据业务属性将接口粗化，将相关的接口方法定义在同一个接口类中。



在学习课程的时候，是会做笔记和回答老师的提问。也就是说每个课程都会做笔记方法和回答问题的方法，在创建课程的时候一并实现做笔记方法和回答问题方法。先定义好相关的接口和类：

课程接口和实现类

```java
public interface ICourse {

    /**
     * 创建课程
     */
    void create();
}

public class EnglishCourseImpl implements ICourse {
    @Override
    public void create() {
        System.out.println("EnglishCourse创建了英语课程");
    }
}

public class MathCourseImpl implements ICourse {
    @Override
    public void create() {
        System.out.println("MathCourseImpl创建了数学课程");
    }
}

```

回答问题接口和实现类

```java
public interface IAnswer {
    /**
     * 回答问题
     */
    void speak();
}

public class EnglishAnswerImpl implements IAnswer {
    @Override
    public void speak() {
        System.out.println("回答英语问题");
    }
}

public class MathAnswerImpl implements IAnswer {
    @Override
    public void speak() {
        System.out.println("回答数学问题");
    }
}
```

笔记接口和实现类

```java
public interface INote {
    /**
     * 做笔记
     */
    void edit();
}

public class EnglishNoteImpl implements INote {
    @Override
    public void edit() {
        System.out.println("写英语笔记");
    }
}

public class MathNoteImpl implements INote {
    @Override
    public void edit() {
        System.out.println("写数学笔记");
    }
}
```

接着定义课程抽象工厂

```java
public abstract class CourseFactory {
    public void init(){
        System.out.println("初始化参数");
    }

    /**
     * 创建笔记
     */
    public abstract INote createNote();

    /**
     * 回答问题
     */
    public abstract IAnswer createAnswer();
}


public class EnglishCourseFactory extends CourseFactory {
    @Override
    public INote createNote() {
        return new EnglishNoteImpl();
    }

    @Override
    public IAnswer createAnswer() {
        return new EnglishAnswerImpl();
    }
}

public class MathCourseFactory extends CourseFactory {
    @Override
    public INote createNote() {
        super.init();
        return new MathNoteImpl();
    }

    @Override
    public IAnswer createAnswer() {
        return new MathAnswerImpl();
    }
}
```

客户端使用：

```java
public class Test {

    public static void main(String[] args) {
        CourseFactory factory = new MathCourseFactory();
        factory.createNote().edit();
        factory.createAnswer().speak();
    }
}
输出：
初始化参数
写数学笔记
回答数学问题
```

**抽象工厂模式的优点**

- 具体产品在应用层代码隔离，无须关系创建细节
- 将一个系列的产品族统一到一起创建

**抽象工厂模式的优点**

- 规定了所有可能被创建的产品集合，产品族扩展新的产品困难，需要修改抽象工厂的接口
- 增加了系统的抽象性和理解难度

**适用范围**

- 强调一系列相关的产品对象一起使用，创建对象需要大量重复代码
- 客户端不依赖于产品类如何被创建、实现等细节



**简单工厂、工厂方法、抽象工厂三者的理解**

> 在一些简单场景，且未来可能不发生变化或变化较少的情况下使用简单工厂；
>
> 较复杂的情况下使用工厂方法；
>
> 抽象工厂需要结合业务理解和发展来考虑的，在设计和开发期间比较难考虑产品的未来发展，通常使用工厂方法模式即可；面对已有的并且有大量重复代码可以使用抽象工厂模式进行代码优化。

## 单例模式

> 单例模式能够确保某一个类只有一个实例，并提供一个全局访问点。单例隐藏了所有的构造方法，属于创建型模式。

### 饿汉式单例

一个简单的饿汉式单例，在类初始化的时候创建。

```java
public class HungrySingleton {

    private static final HungrySingleton hungrySingleton = new HungrySingleton();

    public HungrySingleton() {
    }

    public static HungrySingleton getInstance() {
        return hungrySingleton;
    }
}
```

优点：执行效率高，性能高，没有任何的锁

缺点：某些情况下，会造成浪费内存

### 懒汉式单例 

#### 线程不安全懒汉式

一个简单的饿汉式单例，需要的时候才创建实例。

```java
public class LazySimpleSingleton {

    private static LazySimpleSingleton instance;

    private LazySimpleSingleton() {
    }

    public static LazySimpleSingleton getInstance() {
        if (instance == null) {
            instance = new LazySimpleSingleton();
        }
        return instance;
    }
}
```

优点：节省了内存

缺点：线程不安全



线程不安全是如何体现的，示例:

```java
// 实现一个线程类
public class ExecutorThread implements Runnable {
    @Override
    public void run() {
        LazySimpleSingleton instance = LazySimpleSingleton.getInstance();
        System.out.println(Thread.currentThread().getName() + ":" + instance);
    }
}

// 测试方法
public class LazySimpleSingletonTest {

    public static void main(String[] args) {
        Thread t1 = new Thread(new ExecutorThread());
        Thread t2 = new Thread(new ExecutorThread());
        t1.start();
        t2.start();
        System.out.println("执行结束");
    }
}
```

出现两种运行结果：

![](.\pics\线执行结果相同.png)



![](./pics/线执行结果不同.png)

- 结果出现同一个实例
  1. 正常顺序执行
  2. 后者覆盖前者

- 出现不同的实例
  1. 同时进入条件，按顺序返回

原因是创建实例时**`instance = new LazySimpleSingleton();`**不是一个原子类操作，存在线程风险。

#### synchronized安全懒汉式单例

那么我们只要给创建实例的方法加一个synchronized关键字就可以解决线程风险的问题：

```java
public class LazySimpleSingleton {
	
    private synchronized static LazySimpleSingleton instance;

    private LazySimpleSingleton() {
    }

    public static LazySimpleSingleton getInstance() {
        if (instance == null) {
            instance = new LazySimpleSingleton();
        }
        return instance;
    }
}
```

此时饿汉式单例能够节省内存，同时线程安全；但是加锁后有明显的性能瓶颈！



优化的第一个思路是降低锁的粒度，由方法级粒度到代码级粒度

```java
public class LazyDoubleCheckSimpleSingleton {

    private static LazyDoubleCheckSimpleSingleton instance;

    private LazyDoubleCheckSimpleSingleton() {
    }

    public  static LazyDoubleCheckSimpleSingleton getInstance() {
        synchronized(LazyDoubleCheckSimpleSingleton.class){
            if (instance == null) {
                instance = new LazyDoubleCheckSimpleSingleton();
            }
        }
        return instance;
    }
}
```

锁粒度的缩小并没有解决核心问题—多个线程每次同时获取实例时都会阻塞；进一步优化将阻塞到第一次创建实例时，因为在instance不为空的时候没必要阻塞，会跳过实例化的过程。

```java
public class LazyDoubleCheckSimpleSingleton {

    private static LazyDoubleCheckSimpleSingleton instance;

    private LazyDoubleCheckSimpleSingleton() {
    }

    public static LazyDoubleCheckSimpleSingleton getInstance() {
        if (instance == null) {
            synchronized (LazyDoubleCheckSimpleSingleton.class) {
                instance = new LazyDoubleCheckSimpleSingleton();
            }
        }
        return instance;
    }
}
```

如上代码，只有在实例不等于空的时候，才会阻塞，这样大大降低了阻塞的概率。但同时引发了另一个问题，线程1和线程2同时执行到synchronized代码块时，线程1获得CPU执行权成功new了新实例，接着线程2获取CPU执行权将又会执行一遍new实例，此时线程2获取的新实例会覆盖线程1获取的实例。起初引入synchronized关键字是为了解决重复创建的问题，但是有了性能瓶颈，优化着又回到了原点。

#### 双重检查锁单例

此时可以用双重检查锁同时解决以上问题：

```java
public class LazyDoubleCheckSimpleSingleton {

    private static LazyDoubleCheckSimpleSingleton instance;

    private LazyDoubleCheckSimpleSingleton() {
    }

    public static LazyDoubleCheckSimpleSingleton getInstance() {
        // 检查是否需要阻塞
        if (instance == null) {
            synchronized (LazyDoubleCheckSimpleSingleton.class) {
                // 检查是否还要创建单例
                if (instance == null) {
                    instance = new LazyDoubleCheckSimpleSingleton();
                }
            }
        }
        return instance;
    }
}
```

双重检查锁解决了线程不安全问题，同时大大优化了性能问题；可它也还是有问题的，线程还有个指令重排序的问题：创建对象实例时，会分为三步：

1. 分配对象内存
2. 调用构造器方法，执行初始化
3. 将对象引用赋值给变量

虚拟机实际运行时，为优化程序性能可能发生重排序。步骤 2,3 可能发生重排序，但是并不会重排序 1 的顺序。也就是说 1 这个指令都需要先执行，因为 2,3 指令需要依托 1 指令执行结果。在单例环境种，不会影响执行结果，但是多线程可能会带来一些问题：

|      | 线程1      | 线程2                      |
| ---- | ---------- | -------------------------- |
| t1   | 分配内存   |                            |
| t2   | 变量赋值   |                            |
| t3   |            | 判断对象是否为null         |
| t4   |            | 由于对象不为null，访问对象 |
| t5   | 初始化对象 |                            |

上面双重检查锁中，如果线程 1 获取到锁进入创建对象实例，这个时候发生了指令重排序。当线程1 执行到 t3 时刻，线程 2 刚好进入，由于此时对象已经不为 Null，所以线程 2 可以自由访问该对象。然后该对象还未初始化，所以线程 2 访问时将会发生异常。

#### 完善的双重检查锁

双重检查锁定模式需要需要使用 `volatile`。`volatile`主要包含两个功能。

1. 保证可见性。使用 `volatile` 定义的变量，将会保证对所有线程的可见性。
2. **禁止指令重排序优化。**

```java
public class LazyDoubleCheckSimpleSingleton {
    /**
     * volatile解决指令重排序的问题
     */
    private volatile static LazyDoubleCheckSimpleSingleton instance;

    private LazyDoubleCheckSimpleSingleton() {
    }

    public static LazyDoubleCheckSimpleSingleton getInstance() {
        // 检查是否需要阻塞
        if (instance == null) {
            synchronized (LazyDoubleCheckSimpleSingleton.class) {
                // 检查是否还要创建单例
                if (instance == null) {
                    instance = new LazyDoubleCheckSimpleSingleton();
                }
            }
        }
        return instance;
    }
}
```

 双重检查锁：

	- 性能高，线程安全
	- 代码可读性难度加大，不够优雅

如何实现一个性能高，线程又安全，且优雅的单例？

#### Java内部类创建单例

```
Java特性：静态内部类在初始化的时候不会被读取，在使用的时候才会加载
```

```java
public class LazyStaticInnerClassSingleton {

    private LazyStaticInnerClassSingleton(){}

    private static LazyStaticInnerClassSingleton getInstance(){
        return LazyHolder.INSTANCE;
    }

    /**
     * 静态内部类
     * 看似是饿汉式单例，实际是懒汉式单例
     * Java特性：静态内部类在初始化的时候不会被读取，在使用的时候才会加载
     * LazyStaticInnerClassSingleton.class
     * LazyStaticInnerClassSingleton$LazyHolder.class
     *
     * 优点：写法优雅，性能高，避免了内存浪费，线程安全
     * 缺点：能够被反射破坏
     */
    private static class LazyHolder{
        private static final  LazyStaticInnerClassSingleton INSTANCE = new LazyStaticInnerClassSingleton();
    }
}
```

利用Java特性实现了看似完美的单例，同时满足性能高、线程安全且足够优雅的单例；但这种方式还有一个隐患，能够被反射破坏。

```java
public class ReflectTest {

    public static void main(String[] args) {
        try {
            Class<?> clazz = LazyStaticInnerClassSingleton.class;
            Constructor declaredConstructor = clazz.getDeclaredConstructor();
            declaredConstructor.setAccessible(true);
            Object instance1 = declaredConstructor.newInstance();
            Object instance2 = declaredConstructor.newInstance();
            System.out.println(instance1 == instance2);
        } catch (Exception e) {
            e.printStackTrace();
        }
    }
}

输出结果：false
```

足以可见利用内部静态类的方式会被反射所破坏...是否可以解决这问题？在构造方法种判断是否存在单例可以解决反射破坏的问题

```java
public class LazyStaticInnerClassSingleton {

    private LazyStaticInnerClassSingleton(){
        // 解决反射破坏单例的问题
        if(LazyHolder.INSTANCE != null){
            throw new RuntimeException("不允许非法访问！");
        }
    }

    private static LazyStaticInnerClassSingleton getInstance(){
        return LazyHolder.INSTANCE;
    }

    /**
     * 静态内部类
     * 看似是饿汉式单例，实际是懒汉式单例
     * Java特性：静态内部类在初始化的时候不会被读取，在使用的时候才会加载
     * LazyStaticInnerClassSingleton.class
     * LazyStaticInnerClassSingleton$LazyHolder.class
     *
     * 优点：写法优雅，性能高，避免了内存浪费，线程安全
     * 缺点：能够被反射破坏
     */
    private static class LazyHolder{
        private static final  LazyStaticInnerClassSingleton INSTANCE = new LazyStaticInnerClassSingleton();
    }
}
```

在构建方法种抛出异常，又回到代码阅读比较困难，不够优雅的问题。

### 注册式单例

在《Java Effective》里面推荐使用枚举式单例。

```java
public enum EnumSingleton {
    /**
     * 全局唯一单例
     */
    INSTANCE;

    private Object data;

    public Object getData() {
        return data;
    }

    public void setData(Object data) {
        this.data = data;
    }

    public static EnumSingleton getInstance() {
        return INSTANCE;
    }
}


public class EnumSingletonTest {

    public static void main(String[] args) {
         // 使用枚举类操作单例
        EnumSingleton instance = EnumSingleton.getInstance();
        // 设置单例
        instance.setData(new Object());
        // 获取单例
        Object data = instance.getData();
        System.out.println(data);
        
        try {
//            Enum
            Class<?> clazz = EnumSingleton.class;
            Constructor declaredConstructor = clazz.getDeclaredConstructor(String.class, int.class);
            declaredConstructor.setAccessible(true);
            Object instance1 = declaredConstructor.newInstance();
            Object instance2 = declaredConstructor.newInstance();
            System.out.println(instance1 == instance2);
        } catch (Exception e) {
            e.printStackTrace();
        }
    }
}
```

这时候使用反射获取单例，同样提示报错

![](./pics/枚举单例失败.png)

原因是枚举类继承enum，内部做了限制：

![](./pics/枚举限制反射破坏单例.png)

当修饰符是enum时，会抛出异常，不能使用反射创建单例。

*Enum类是如何保证单例的创建？*

Enum类有一个valuesOf的方法，可以通过传入枚举常量值获取实例

![](.\pics\枚举1.png)

enumConstantDirectory是一个Map，key是枚举常量名，value是实例。(类似于IOC容器)

![](.\pics\枚举2.png)

这样可以基本得出结论，注册式单例是通过map保存实例，并确保其唯一性；map中可以同时存放多个实例，其本质也是属于饿汉式单例

### 单例模式小结

各种创建单例模式的对比：

| 类型   | 方式               | 优点                           | 缺点                       | 说明                     |
| ------ | ------------------ | ------------------------------ | -------------------------- | ------------------------ |
| 饿汉式 | 简单饿汉式         | 执行效率高，性能高，无锁       | 某些情况下，会造成浪费内存 |                          |
|        | 注册式单例         | 执行效率高，性能高，无锁，优雅 | 某些情况下，会造成浪费内存 | 通过map容器实现          |
| 懒汉式 | 简单饿汉式         | 节省内存                       | 线程不安全                 |                          |
|        | synchronized饿汉式 | 节省内存，同时线程安全         | 存在明显性能瓶颈           |                          |
|        | 双重检查锁         | 性能高，线程安全               | 代码不够优雅               | 使用volatile排除指令重排 |

**单例模式的优点**：

1. 单例模式在内存中只有一个实例，减少了内存开支
2. 单例模式避免对资源的多重占用，例如一个写文件的动作，由于只有一个实例存在内存中，避免对同一个资源文件的同时写操作
3. 单例模式可以在系统设置全局的访问点，优化和共享资源访问

**单例模式的缺点**：

1. 单例模式没有接口，扩展困难。如果要扩展，必须修改代码

**实现单例**：

	1. 私有化构造器
	2. 保证线程安全
	3. 延迟加载
	4. 防御反射破坏单例

单例模式有着两大类实现方式，追求性能且开发简单的是饿汉式单例，可能会牺牲内存；既希望性能高且安全，建议使用双重检查锁单例。

## 原型模式

> 原型模式是指原型实例指定创建对象的种类，并且通过**拷贝**这些原型创建新的对象。调用者不需要知道任何创建细节，不调用构造函数；属于创建型模式。

### 适用场景

在某些业务场景下，需要复用一个类进行操作，通常会使用构造方法或者getter和setter去复制一份：

```java
@Data
public class ExamPaper {
    private String examinationPaperId;//试卷主键
    private String leftTime;//剩余时间
    private String organizationId;//单位主键
    private String id;//考试主键
    private String examRoomId;//考场主键
    private String userId;//用户主键
    private String specialtyCode;//专业代码
    private String positionCode;//报考岗位
    private String gradeCode;//报考等级
    private String examStartTime;//考试开始时间
    private String examEndTime;//考试结束时间
    private String singleSelectionImpCount;//单选选题重要数量
    private String multiSelectionImpCount;//多选题重要数量
    private String judgementImpCount;//判断题重要数量
    private String examTime;//考试时长
    private String fullScore;//总分
    private String passScore;//及格分
    private String userName;//学员姓名
    private String score;//考试得分
    private String result;//是否及格
    private String singleOkCount;//单选题答对数量
    private String multiOkCount;//多选题答对数量
    private String judgementOkCount;//判断题答对数量

    /**
     * 硬编码实现
     */
    public ExamPaper copy(){
        ExamPaper examPaper = new ExamPaper();
        //剩余时间
        examPaper.setLeftTime(this.getLeftTime());
        //单位主键
        examPaper.setOrganizationId(this.getOrganizationId());
        //考试主键
        examPaper.setId(this.getId());
        //用户主键
        examPaper.setUserId(this.getUserId());
        //专业
        examPaper.setSpecialtyCode(this.getSpecialtyCode());
        //岗位
        examPaper.setPositionCode(this.getPositionCode());
        //等级
        examPaper.setGradeCode(this.getGradeCode());
        //考试开始时间
        examPaper.setExamStartTime(this.getExamStartTime());
        //考试结束时间
        examPaper.setExamEndTime(this.getExamEndTime());
        //单选题重要数量
        examPaper.setSingleSelectionImpCount(this.getSingleSelectionImpCount());
        //多选题重要数量
        examPaper.setMultiSelectionImpCount(this.getMultiSelectionImpCount());
        //判断题重要数量
        examPaper.setJudgementImpCount(this.getJudgementImpCount());
        //考试时间
        examPaper.setExamTime(this.getExamTime());
        //总分
        examPaper.setFullScore(this.getFullScore());
        //及格分
        examPaper.setPassScore(this.getPassScore());
        //学员姓名
        examPaper.setUserName(this.getUserName());
        //分数
        examPaper.setScore(this.getScore());
        //单选答对数量
        examPaper.setSingleOkCount(this.getSingleOkCount());
        //多选答对数量
        examPaper.setMultiOkCount(this.getMultiOkCount());
        //判断答对数量
        examPaper.setJudgementOkCount(this.getJudgementOkCount());

        return examPaper;
    }

    @Override
    public String toString() {
        return "ExamPaper{" +
                "examinationPaperId='" + examinationPaperId + '\'' +
                ", leftTime='" + leftTime + '\'' +
                ", organizationId='" + organizationId + '\'' +
                ", id='" + id + '\'' +
                ", examRoomId='" + examRoomId + '\'' +
                ", userId='" + userId + '\'' +
                ", specialtyCode='" + specialtyCode + '\'' +
                ", positionCode='" + positionCode + '\'' +
                ", gradeCode='" + gradeCode + '\'' +
                ", examStartTime='" + examStartTime + '\'' +
                ", examEndTime='" + examEndTime + '\'' +
                ", singleSelectionImpCount='" + singleSelectionImpCount + '\'' +
                ", multiSelectionImpCount='" + multiSelectionImpCount + '\'' +
                ", judgementImpCount='" + judgementImpCount + '\'' +
                ", examTime='" + examTime + '\'' +
                ", fullScore='" + fullScore + '\'' +
                ", passScore='" + passScore + '\'' +
                ", userName='" + userName + '\'' +
                ", score='" + score + '\'' +
                ", result='" + result + '\'' +
                ", singleOkCount='" + singleOkCount + '\'' +
                ", multiOkCount='" + multiOkCount + '\'' +
                ", judgementOkCount='" + judgementOkCount + '\'' +
                '}';
    }
}
```

类的字段比较多的时候，也可以使用反射去实现：

```java
// 反射实现类拷贝
public class BeanUtils {
    public static Object copy(Object protorype) {
        Class clazz = protorype.getClass();
        Object returnValue = null;
        try {
            returnValue = clazz.newInstance();
            for (Field field : clazz.getDeclaredFields()) {
                field.setAccessible(true);
                field.set(returnValue, field.get(protorype));
            }
        } catch (Exception e) {
            e.printStackTrace();
        }
        return returnValue;
    }
}
```

反射简化了代码，不过其本质上还是set和get。



**原型模式不通过new关键字，而是通过clone方法去复制一份，通过方法创建的对象能够保留原来的值。**

适用场景：

1. 类初始化消耗资源较多
2. new产生的一个对象需要非常繁琐的过程（数据准备、访问权限等）
3. 构造函数比较复杂
4. 循环体中产生大量对象时

原型模式标准写法是新建一个原型接口类，定义一个克隆接口；在需要复制的类上去实现这个接口类，并重写克隆方法；这样客户端在调用的时候只需要通过克隆方法就可以获取一个新的对象。

```java
// 原型接口类，包含一个克隆方法
public interface IPrototype<T> {
    T clone();
}

// 类实现原型接口，并重写克隆方法
public class PrototypeImpl implements IPrototype<PrototypeImpl> {
    private int age;
    private String name;

    public int getAge() {
        return age;
    }

    public void setAge(int age) {
        this.age = age;
    }

    public String getName() {
        return name;
    }

    public void setName(String name) {
        this.name = name;
    }

    @Override
    public PrototypeImpl clone() {
        PrototypeImpl prototypeImpl = new PrototypeImpl();
        prototypeImpl.setAge(this.age);
        prototypeImpl.setName(this.name);
        return prototypeImpl;
    }

    @Override
    public String toString() {
        return "prototypeImpl{" +
                "age=" + age +
                ", name='" + name + '\'' +
                '}';
    }
}

//3.适用clone方法
public class Client {
    public static void main(String[] args) {
        //创建原型对象
        PrototypeImpl prototype = new PrototypeImpl();
        prototype.setAge(18);
        prototype.setName("Tom");
        System.out.println(prototype);

        //拷贝原型对象
        PrototypeImpl cloneType = prototype.clone();
        System.out.println(cloneType);
    }

}

```

原型模式的核心是克隆复制方法；复制有两种克隆，一种是浅克隆，一种是深克隆。

### 浅克隆

在上面的示例中，如果类属性很多的话，那么要一个个的set和get，这种硬编码的方式就会很繁琐。JDK中有一个现成的API，实现Cloneable接口，那么就可以使用它的clone方法：

```java
// 继承Cloneable接口，通过clone方法来实现克隆
@Data
public class PrototypeImpl implements Cloneable {
    private int age;
    private String name;
    private List<String> hobbies;

    @Override
    public PrototypeImpl clone() {
        try {
            return (PrototypeImpl)super.clone();
        } catch (CloneNotSupportedException e) {
            e.printStackTrace();
        }
        return null;
    }

    @Override
    public String toString() {
        return "PrototypeImpl{" +
                "age=" + age +
                ", name='" + name + '\'' +
                ", hobbies=" + hobbies +
                '}';
    }
}

//客户端调用
public class Client {
    public static void main(String[] args) {
        //创建原型对象
        PrototypeImpl prototype = new PrototypeImpl();
        prototype.setAge(18);
        prototype.setName("Tom");
        List<String> hobbies = new ArrayList<>();
        hobbies.add("编程");
        hobbies.add("看书");
        prototype.setHobbies(hobbies);

        //拷贝原型对象
        PrototypeImpl cloneType = prototype.clone();
        cloneType.getHobbies().add("加班");
        System.out.println("原型对象" + prototype);
        System.out.println("克隆对象" + cloneType);
        System.out.println(cloneType == prototype);

        System.out.println(prototype.getHobbies() == cloneType.getHobbies());
    }

}

输出结果：
原型对象PrototypeImpl{age=18, name='Tom', hobbies=[编程, 看书, 加班]}
克隆对象PrototypeImpl{age=18, name='Tom', hobbies=[编程, 看书, 加班]}
false
true
```

在`PrototypeImpl`中新增了爱好属性，为`List`类型。在复制的时候，希望克隆出来的对象和原型对象是两个独立的对象，不应该再有联系。但是输出结果中，发现改变了拷贝对象，原型对象也随之变化了。

通过第一个对比结果为true，能够确认`cloneTyp`e和`protoType`确实为两个不同的对象，结果为false；但是他们的属性hobbies，却是指向同一个地址的。也就是说**只是完整复制了值类型数据，没有赋值引用对象**，这就是浅克隆。下面通过深克隆来解决浅克隆的问题，让引用对象不再指向原来对象。

### 深克隆

在浅克隆的基础上继续改造，新增一个`deepClone`方法：

```java
// 注意序列化
@Data
public class PrototypeImpl implements Cloneable, Serializable {
    private int age;
    private String name;
    private List<String> hobbies;

    @Override
    public PrototypeImpl clone() {
        try {
            return (PrototypeImpl) super.clone();
        } catch (CloneNotSupportedException e) {
            e.printStackTrace();
        }
        return null;
    }

    // 通过流实现深克隆
    public PrototypeImpl deepClone() {
        try {
            ByteArrayOutputStream byteArrayOutputStream = new ByteArrayOutputStream();
            ObjectOutputStream objectOutputStream = new ObjectOutputStream(byteArrayOutputStream);
            objectOutputStream.writeObject(this);

            ByteArrayInputStream byteArrayInputStream = new ByteArrayInputStream(byteArrayOutputStream.toByteArray());
            ObjectInputStream objectInputStream = new ObjectInputStream(byteArrayInputStream);
            return (PrototypeImpl) objectInputStream.readObject();
        } catch (Exception e) {
            e.printStackTrace();
            return null;
        }
    }

    @Override
    public String toString() {
        return "PrototypeImpl{" +
                "age=" + age +
                ", name='" + name + '\'' +
                ", hobbies=" + hobbies +
                '}';
    }
}

// 客户端调用
public class Client {
    public static void main(String[] args) {
        //创建原型对象
        PrototypeImpl prototype = new PrototypeImpl();
        prototype.setAge(18);
        prototype.setName("Tom");
        List<String> hobbies = new ArrayList<>();
        hobbies.add("编程");
        hobbies.add("看书");
        prototype.setHobbies(hobbies);

        //拷贝原型对象
        PrototypeImpl cloneType = prototype.deepClone();
        cloneType.getHobbies().add("加班");
        System.out.println("原型对象" + prototype);
        System.out.println("克隆对象" + cloneType);
        System.out.println(cloneType == prototype);

        System.out.println(prototype.getHobbies() == cloneType.getHobbies());
    }
}

输出结果：
原型对象PrototypeImpl{age=18, name='Tom', hobbies=[编程, 看书]}
克隆对象PrototypeImpl{age=18, name='Tom', hobbies=[编程, 看书, 加班]}
false
false   
```

此时深克隆得到了期望的结果，引用对象类型不再指向原来对象。

### 源码中的应用

使用`ArrayList`时默认构造容量大小时10，当`ArrayList`中的元素超过10个以后，会重新分配内存空间。这其中就会进行一次克隆操作，将原来的元素拷贝到新的内存空间中

![](.\pics\ArrayList扩容复制.png)

同理HashMap中的扩容复制

![](.\pics\hashMap扩容复制.png)



## 建造者模式

> 建造者模式是将一个复杂对象的构建过程与它的表示分离，使同样的构建过程可以创建不同的表示，属于创建型模式。使用建造者模式对于用户而言只需指定需要创建的类型就可以获得创建对象，创造过程及细节不需要了解。

建造者模式适用于创建对象需要很多步骤，但是步骤的顺序不一定固定。如果一个对象有很复杂的内部结构，可以将对象的创建和使用进行分离。

### 建造者模式的适用场景

建造者模式适用于，当需求变化时，组成产品的各个零件经常发生猛烈变化，但是它们的组合方式全相对稳定。

1. 相同方法，不同的执行顺序，产生不同的结果
2. 多个部件或零件，都可以装配到一个对象中，但是结果又不相同
3. 产品类非常复杂，产品类中的不同调用顺序产生不同的结果
4. 初始化一个对象特别复杂，参数多而且很多大都具有默认值时。

### 建造者模式的写法

以课程为例，一个课程有ppt、视频、笔记、课后作业等组成，这些内容的顺序可以任意调换，可以部分属性有部分属性没有。

```java
// 产品类-课程
@Data
public class Course {

    private String name;

    private String ppt;

    private String video;

    private String note;

    private String homework;

    @Override
    public String toString() {
        return "Course{" +
                "name='" + name + '\'' +
                ", ppt='" + ppt + '\'' +
                ", video='" + video + '\'' +
                ", note='" + note + '\'' +
                ", homework='" + homework + '\'' +
                '}';
    }

}

// course的建造者，将构造过程封装起来，构造步骤由用户决定
public class CourseBuilder {

    private Course course = new Course();

    public CourseBuilder addName(String name) {
        course.setName(name);
        return this;
    }

    public CourseBuilder addPpt(String ppt) {
        course.setPpt(ppt);
        return this;
    }

    public CourseBuilder addVideo(String video) {
        course.setVideo(video);
        return this;
    }

    public CourseBuilder addNote(String note) {
        course.setNote(note);
        return this;
    }

    public CourseBuilder addHomework(String homework) {
        course.setHomework(homework);
        return this;
    }

    public Course builder() {
        return course;
    }
}

//测试类
public class Test {
    public static void main(String[] args) {
        CourseBuilder builder = new CourseBuilder()
                .addName("设计模式").addPpt("wiki上的链接")
                .addNote("Eamon的笔记");
        System.out.println(builder.builder());
    }
}

```

建造者模式通常是采用链式编程的方法构造对象。



### 源码中的引用

StringBuilder的append方法

![](.\pics\StringBuilder应用建造者模式.png)

还有SQL的构造方法QueryRuleSqlBuilder、Mybatis中的SqlSessionFactoryBuilder中的builder方法等。

**建造者模式优点**：

- 封装性好，创建和使用分离
- 扩展性好，建造类之间独立、一定程度解耦

**建造者模式缺点**：

- 产生多余的Builder对象
- 产品内部发生变化，建造者都要修改，成本较大

建造者和工厂模式都属于创建者，但它们是有区别的：**工厂模式注重的是整体对象的创建方法，而建造者模式注重的是对象的创建过程，创建对象的过程方法可以在创建时自由调用**。

